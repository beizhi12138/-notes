# 多线程
 一个进程就是一个正在运行的程序。
 线程就是进程中的执行单位。
 一个进程里可以有多个线程故而称之为多线程(一个线程只属于一个进程)。
   线程执行相当于去抢cpu执行的，当执行一个线程未执行完事可能下一个线程开始执行了。
## 线程创建
java中线程创建的方式有两种:一种是集成Thread类，如果类继承了Thread类那么这个类就被成为线程类，一种是实现接口
### 继承Thread类
  继承Thread类必须实现run方法。
  创建了几个线程类对象就相当于有几个线程
  启用线程必须使用start方法
    
        线程类的常用方法
          
           start()  启用线程
           setName() 线程命名
           getName() 获取线程名称

```java
public class ThreadDemo extend Thread{
    public void run(){
        for(int i=0;i<100;i++){
            System.out.println(getName()+i);
        }
    }
}
public class void test(){
     public static void main(String[] aargs){
        
        //创建线程类对象，创建几个线程类对象相当于几个线程
         ThreadDemo threadDemo=new ThreadDemo();
         threadDemo.setName("线程1");
         threadDemo.setName("线程2");
         ThreadDemo threadDemo2=new ThreadDemo();
         //启用线程
         threadDemo.start();
         threadDemo2.start();
    }
}
```
### 实现Runnable接口
  实现Runnable是实现的run 方法，使用runnable的好处就是能够操作多个线程之间数据的共享 

```java 
public class RunnableDemo implements Runnable{
    public void run(){
       for(int i=0;i<100;i++){
        System.out.peintln(Thread.currentThread().getName());
       }
    } 
}

public class test{
    public static void main(String[] args){
       RunnableDemo runnableDemo=new RunnableDemo();

       //开启线程需要转Threa对象
       ThreaD thread=new Thread(runnableDemo);
       thread.start();
    }
}
```
### 线程的执行状态
   线程是有生命周期的
      new Thread(创建线程类对象) 线程新生
      start(启动线程) 线程准备期
      cpu分配   运行状态  当cpu分配给哪个线程，线程就是运行状态

      当线程未执行完，cpu被分配给其他线程，那么当前的线程进入准备状态，等待cpu分配

      当线程执行完毕 线程进入死亡状态

      当cpu分配给线程时，线程被其他因素终端，线程进入阻塞状态，当线程阻塞结束延时阻塞结束后进入准备状态等待继续执行。

      当线程进入阻塞状态时，cpu则会被分配给其他线程
 ###  多线程高并发和并行
  高并发就是一段时间内cpu执行多个线程

  并行就是同一时刻多个线程同时执行(并行只发生在多cpu的情况下)

  ## 线程调度
  ### 线程优先级
    
      通过setPriority进行设置线程优先级，参数是0-10数字越大优先级越高，默认线程的优先级是5 ,设置优先级只是可以保证线程的邮优先级，并不能完全保证线程还是随机的。

      join方法也可以进行优先级的提高。在线程开启之后调用该线程的join方法那么其他线程就需要等待当前开启join的线程先执行完

      yield yield方法是礼让一般在run方法中调用就是先暂停当前线程的执行，礼让给其他线程

      sleep 线程睡眠，参数是毫秒

      setDaomon 守护线程，守护线程就是当其他线程执行完成之后，守护线程结束。

```java
public RunableDemo1 implments Runnable{
    public void run(){
        for(int i=0;i<100;i++){
            System.out.println(1);
        }
    }
}
public class test {
 public static void main(String[] args){
   RunnableDemo1 demo1=new RunnableDemo1();
   RunnableDemo1 demo2=new RunnableDemo1();
   demo1.setPriotirty(10);
   demo2.setPriotirty(1);
   demo1.start();
   demo2.start();
   //demo1先运行的机率比demo2的概率大
 }
}
```
## 线程安全
### 线程锁
 通过关键字可以保证代码执行完成之后才能被下一个进程执行

 synchornized 关键字

 这个关键字也可以写到方法上


 ```java
 //同步代码块，同步代码块需要添加锁，保证不同进程操作的锁是一样的
public class ThreadDemo implements Runnable{
    private int num=100;
    private Object obj=new Object();
    @Override
    public void run() {
        while(true){
            synchronized (obj){
                if(num > 0){
                    System.out.println(Thread.currentThread().getName()+"卖了"+num+"票");
                    this.num--;
                }else{
                    break;
                }
            }
        }
    }
}
//锁方法，锁方法的话那么当前的锁就是this

public class ThreadDemo implements Runnable{
    private int num=100;
    private Object obj=new Object();
    @Override
    public void run() {
        while(true){
            test();
        }
    }
    public synchronized void test(){
        if(num > 0){
            System.out.println(Thread.currentThread().getName()+"卖了"+num+"票");
            this.num--;
        }
    }
}
//静态方法锁,静态方法锁的锁是当前的类
public class ThreadDemo implements Runnable{
    public static int num=100;
    private Object obj=new Object();
    @Override
    public void run() {
        while(true){
            test();
        }
    }
    public synchronized static void test(){
        if(ThreadDemo.num > 0){
            System.out.println(Thread.currentThread().getName()+"卖了"+num+"票");
            num--;
        }
    }
}

 ```

 ### Lock锁
  Lock就是一个同步锁的抽象类。
  Lock的实现类 

  有两个方法 lock() 加锁
             unlock() 结束锁

### 死锁
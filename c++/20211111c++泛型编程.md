# 模板
 模板就是建立通用的模具，提高复用性。
 ## 函数模板
  c++中另一种编程思想为泛型变成，主要利用的技术就是模板。
  c++中提供两种模板机制：函数模板和类模板
### 函数模板语法

       函数模板语法: 
          template<typename T>
           函数声明或定义

             template    声明创建模板
             typename   其后面跟着的是一种数据类型，可以用class代替
             T   通用的数据类型


            函数模板有两种使用方式:
               1.自动类型推导
               2.显示指定类型

```cpp
//函数模板
template <typename T> //后面的T是一个通用数据类型，告诉编译器不要报错
void mySwap(T &a,T &b){
   T temp=a;
   a=b;
   b=temp;
}
int main(){
    int a=10;
    int b=20;
//1.自动类型推导
    //mySwap(a,b);
//2. 显示指定类型
    //  mySwap<int>(a,b);
    cout <<a<<endl;
    cout << b<<endl;
    system("pause");
    return 0;
}
```
### 注意事项
   自动类型推导，必须推导出一致的数据类型T，才可以使用。
   模板必须要确定出T的数据类型，才可以使用、

```cpp
//函数模板demo 
/**
   实现通用对数组进行排序的函数
   规则：升序
   算法：快排
   测试  char 数组，int数组
 */
//交换函数
template <class T> //后面的T是一个通用数据类型，告诉编译器不要报错,typename可以用calss代替
void mySwap(T &a, T &b)
{
    T temp = a;
    a = b;
    b = temp;
}
//排序函数
template <class T>
void mySort(T arr[], int length)
{
    for (int i = 0; i < length; i++)
    {
        int min = i; //基准
        for (int j = i + 1; j < length; j++)
        {
            if (arr[min] > arr[j])
            {
                min = j;
            }
        }
        if (i != min)
        {
            mySwap(arr[i], arr[min]);
        }
    }
}
//输出函数
template <class T>
void myPrint(T arr[], int len)
{
    for (int i = 0; i < len; i++)
    {
        cout << arr[i] << endl;
    }
}
void test01()
{
    //字符数组
    char arr[] = "bcdeaf";
    int len = sizeof(arr) / sizeof(arr[0]);
    mySort(arr, len);
    myPrint(arr, len);
}
void test02()
{
    int arr[] = {6, 7, 3, 2, 10, 8};
    int len = sizeof(arr) / sizeof(arr[0]);
    mySort(arr, len);
    myPrint(arr, len);
}
int main()
{
    test01();
    test02();
    system("pause");
    return 0;
}
```
### 普通函数与函数模板的区别
 普通函数调用时可以发生自动类型转换(隐式类型转换)
 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换
 如果利用显示指定类型，可以发生自动类型推导
 ### 普通函数与函数模板的调用规则
   如果普通函数和模板函数都可以实现，优先调用普通函数
   可以通过空模板参数列表来强制调用函数模板
   函数模板也可以发生重载
   如果函数模板可以产生更好的匹配，优先调用函数模板。
### 模板的局限性
  模板并不是万能的
  ## 类模板
    建立一个通用类，类中的成员数据类型可以不具体制定，用一个虚拟的类型来代表。
    类模板和函数模板的语法相似，在template语句下写一个类，就是类模板
```cpp
template <class nameType,class ageType> //后面的T是一个通用数据类型，告诉编译器不要报错,typename可以用calss代替
class Person{
   public :
      nameType name;
      ageType  age;
     Person(nameType name,ageType age){
        this->name=name;
        this->age=age;
     }
    void showInfo(){
        cout << name << age <<endl;
     } 
};
int main()
{
    Person<string,int> p1("Tom",19);
    p1.showInfo();
    system("pause");
    return 0;
}
```
### 类模板与函数模板的区别
      类模板没有自动类型推导的使用方式
      类模板在模板参数列表中可以有默认参数
```cpp
#include <iostream>
using namespace std;
#include <string>
template <class nameType=string,class ageType=int>//默认参数
class Person{
   public :
      nameType name;
      ageType  age;
     Person(nameType name,ageType age){
        this->name=name;
        this->age=age;
     }
    void showInfo(){
        cout << name << age <<endl;
     } 
};
int main()
{
    Person<string> p("tim",20); 
    p.showInfo();
    Person<string,int> p1("Tom",19);
    p1.showInfo();
    system("pause");
    return 0;
}
```
### 类模板中成员函数创建时机 
   普通类中的成员函数一开始就可以创建，
   类模板中的函数在调用时才创建
```cpp
#include <iostream>
using namespace std;
#include <string>
class p1{
    public :
     void showInfo(){
        cout << "p1SowInfo" <<endl;
     }
};
class p2{
    public:
      void showInfo2(){
        cout << "p2showInfo"<<endl;
      }
};
template <class T>//默认参数
class Person{
   public :
   T obj;
   void func1(){
     obj.showInfo();
   } 
   void func2(){
       obj.showInfo2();
   }
};
int main()
{
    p1 p;
    Person<p1> p3;
    p3.func1();
    //p3.func2(); 在调用时才被创建
    system("pause");
    return 0;
}
```
### 类模板对象做函数参数
 类模板实例化出的对象，向函数传参的方式

    指定传入的类型  直接显示对象的数据类型
    参数模板化      将对象中的参数做为模板进行传递
    整个类模板化    将这个对象类型模板化进行传递

    最常用的是指定传入类型
```cpp
#include <iostream>
using namespace std;
#include <string>
template <class T, class T2> //默认参数
class Person
{
public:
    T name;
    T2 age;
    Person(T name, T2 age)
    {
        this->name = name;
        this->age = age;
    }
    void toString()
    {
        cout << this->name << this->age << endl;
    }
};
//指定传入类型
void printPerson(Person<string, int> &p)
{

    p.toString();
}
void test01()
{
    Person<string, int> p("Tom", 18);
    //类模板做函数参数
    printPerson(p);
}
//参数模板化
template <class T, class T2>
void printPerson2(Person<T, T2> &p)
{
    p.toString();
    cout << "T  type" << typeid(T).name() << endl;
    cout << "T1  type" << typeid(T2).name() << endl;
}
void test02()
{
    Person<string, int> p("zhangsan", 20);
    //类模板做函数参数
    printPerson2(p);
}
//整个类模板化
template <class T>
void printPerson3(T &p)
{
    p.toString();
    cout << "T type" << typeid(T).name() << endl;
}
void test03()
{
    Person<string, int> p("lisi", 56);
    printPerson3(p);
}
int main()
{
    test01();
    test02();
    test03();
    system("pause");
    return 0;
}
```
### 类模板与继承
   当子类继承的父类是一个类模板时，子类在声明的时候要指定出父类中T 的类型
   如果不指定，编译器无法给子类分配内存
   如果想灵活指定出父类中T 的类型，子类也需要变为类模板

```cpp

template <class T, class T2> //默认参数
class Person
{
public:
    Person()
    {
        cout << "T type" << typeid(T).name() << endl;
        cout << "T2 type" << typeid(T2).name() << endl;
    }
};
//必须指定出父类类型
class Son : public Person<int, char>
{
};
//灵活运行，子类必须也是一个类模板
template <class T1, class T, class T2>
class Son2 : public Person<T, T2>
{
public:
    Son2()
    {
        cout << "T type" << typeid(T).name() << endl;
        cout << "T2 type" << typeid(T2).name() << endl;
        cout << "T1 type" << typeid(T1).name() << endl;
    }
};
void test01()
{
    Son s;
    Son2<int, char, double> s2;
}

int main()
{
    test01();
    system("pause");
    return 0;
}
```
### 类模板成员函数类外实现

```cpp
template <class T, class T2> //默认参数
class Person
{
public:
    Person(T name, T2 age);
    T name;
    T2 age;
    void  toString();
};
//成员函数类外实现
template <class T, class T2> 
Person<T,T2>::Person(T name,T2 age)
{
    this->name = name;
    this->age = age;
}
template <class T, class T2> 
void Person<T,T2>::toString(){
  cout << this->name << this->age <<endl;
}
void test01()
{
    Person<string,int> p("Tom",18);
    p.toString();
}

int main()
{
    test01();
    system("pause");
    return 0;
}
```
### 类模板分文件编写
  类模板中成员函数的创建时机是在调用阶段，导致分文件编写时链接不到。

    解决方式1：直接包含.cpp源文件
    解决方式2: 将声明和实现写到同一个文件中，并更改后缀名为.hpp,hpp是约定的名称
```cpp
#include <iostream>
using namespace std;
#include <string>
//第一种解决方式直接引入源文件,还是正常的分文件编写，但是在引入的时候直接引入源文件
//#include "./lib/Person.cpp"
//第二种解决方式,将声明和实现写在同一个文件中，文件后缀为hpp ,推荐用第二种方式
#include "./includes/Person.hpp"
void test01()
{
    Person<string,int> p("Tom",18);
    p.toString();
}

int main()
{
    test01();
    system("pause");
    return 0;
}
```
### 类模板与友元
  全局函数类内实现，直接在类内声明友元即可
  全局函数类外实现，需要提前让编译器知道全局函数的存在

```cpp
template <class T1,class T2>
class Person;
//全局函数类外实现
template <class T1,class T2>
void printPerson2(Person<T1,T2> p){
    //如果是全局函数类外实现，需要让编译器提前知道有这个函数
     cout << p.name <<p.age<<endl;
};
template <class T1,class T2>
class Person{
    //全局函数类内实现
   friend void printPerson(Person<T1,T2> p){
        cout << p.name <<p.age<<endl;
    }
    //全局函数类外实现 ,
    // 加空参数模板列表
    // 如果全局函数是类外实现，需要让编译器提前知道有这个函数存在
    friend void printPerson2<>(Person<T1,T2> p); 
    public:
     Person(T1 name,T2 age){
           this->name=name;
           this->age=age;
     };
    private :
      T1 name;
      T2  age;
};

void test01()
{
    Person<string,int> p("Tom",18);
    printPerson(p);
    printPerson2(p);
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
```cpp
//类模板案例
/**
  实现一个通用的模板类
    可以对内置的数据类型，也可以对自定义数据类型进行存储
    将数组中的数据存储到堆去
    构造函数中可以传入数组的容量
    提供对应的拷贝构造函数以及operator=防止浅拷贝问题
     提供push 和pop方法对数组增删
     可以通过下标访问数组中的元素
     可以获取length和数组的容量
 */

 //Array.hpp
 #pragma once
#include <iostream>
using namespace std;
template <class T>
class Array
{
private:
    T *arrAddress; //开辟在堆区的真实数组
    int length;    //数组元素的个数
    int size;      //数组的容量
public:
    // 有参构造，设置数组的容量，以及初始化属性
    Array(int size)
    {
        this->size = size;
        this->length = 0;
        this->arrAddress = new T[this->size];
    }
    //拷贝构造函数
    Array(const Array &arr)
    {
        this->size = arr.size;
        this->length = arr.length;
        //重新开辟内存空间，防止堆区数据重复释放
        this->arrAddress = new T[arr.size];
        //如果有数据将数据放进去
        for (int i = 0; i < this->length; i++)
        {
            this->arrAddress[i] = arr.arrAddress[i];
        }
    }
    //重载=运算符
    Array &operator=(const Array & arr)
    { 
       //先判断原来的堆区是否有数据，有则释放干净
       if (this->arrAddress != NULL) {
         delete [] this->arrAddress;
         this->arrAddress=NULL;
         this->size=0;
         this->length=0;
       }   
       this->size=arr.size;
       this->length=arr.length;
       this->arrAddress=new T[arr.size];
       //拷贝过来原来的数据
       for(int i=0;i<this->length;i++){
        this->arrAddress[i]=arr.arrAddress[i];
       }
       //返回当前对象
       return *this;
    }
    //析构函数
    ~Array()
    {
        if (this->arrAddress != NULL)
        {
            delete[] this->arrAddress;
            this->arrAddress = NULL;
        }
    }
    //push方法
    void push(T val){
      if(this->size == this->length){
        return;
      }
      this->arrAddress[this->length]=val;
      this->length++;
    }
    //pop方法
    void pop(){
          if(this->length == 0){
            return;
          }
           this->length--;
    }
    //重写[] 利于arr[i]这样访问
    //返回引用以便于重新赋值
    T& operator[](int index){
          return this->arrAddress[index];
    }
    //返回length
    int get_Length(){
        return this->length;
    }
    //返回size
    int get_Size(){
        return this->size;
    }
};
//main函数
#include <iostream>
using namespace std;
#include <string>
#include "./includes/Array.hpp"
void printArr(Array<int> &arr){
  for(int i=0;i<arr.get_Length();i++){
    cout <<arr[i] <<endl;
  }
};
void test01()
{
   Array<int> arr1(5);
   for(int i=0;i<5;i++){

    arr1.push(i+1);
   }
   cout << "arr1"<<endl;
   printArr(arr1);
   cout << "arr1 length" << arr1.get_Length() <<endl;
   cout <<  "arr1 size" << arr1.get_Size()<<endl;
   Array<int> arr2(arr1);
   cout << "arr2"<<endl;
   arr2.pop();
   printArr(arr2);
   cout << "arr2 length" << arr2.get_Length() <<endl;
   cout <<  "arr2 size" << arr2.get_Size()<<endl;
};
//测试数组，存储自定义数据类型
class Person{
    public:
     int age;
     string name;
     Person(){}
     Person(int age,string name){
        this->age=age;
        this->name=name;
     }
};
void printPersonArr(Array<Person> & arr){
  for(int i=0;i<arr.get_Length();i++){
    cout << arr[i].name << arr[i].age <<endl;
  }
};
void test02(){
    Array<Person> arr(10);
    Person p1(20,"tom");
    Person p2(28,"tim");
    arr.push(p1);
    arr.push(p2);
    printPersonArr(arr);
}
int main()
{
    test01();
    test02();
    system("pause");
    return 0;
}
```
# STL
c++的面向对象和泛型变成思想，目的就是复用性的提升。但是数据结构和算法未能有一套标砖导致从事大量重复，为了建立数据结构和算法的一套标准，诞生了STL
## 基本概念
  STL从广义上分为:容器，算法，迭代器
  容器和算法之间通过迭代器进行无缝衔接
  STL几乎所有的代码都采用了模板类或者模板函数。

  ## STL六大组件
    STL大体分为六大组件分别是:容器。算法，迭代器，仿函数，适配器，空间配置器

        容器: 各种数据结构，list,queue,map等用来存放数据
        算法: 各种常用的算法，排序，查找，copy,遍历等
        迭代器:扮演了容器与算法之间的胶合剂
        仿函数: 行为类似函数，可作为算法的某种策略
        适配器:一种用来修饰容器或者仿函数或迭代器接口的东西。
        空间配置器: 负责空间的配置与管理


 ## STL容器，算法，迭代器
   STL容器运用最广泛的一些数据结构实现出来。

   常用的数据结构:数组，链表，栈，树，队列，集合，映射表等。

     容器分为  序列式容器:数组，队列，栈
               关联式容器: 链表，树

        算法分为质变算法和非质变算法
             质变算法: 运算过程中会更改区间内的元素的内容，例如替换，删除等
             非质变算法:是指运算过程中不会更改区间的元素内容，例如查找，遍历等

             迭代器:提供一种方法，使之能够依序访问某个容器所含的各个元素，每个容器都有自己的迭代器。
             迭代器非常类似于指针。

                 迭代器有五种

                     输入迭代器  对数据只读
                     输出迭代器  对数据只写
                     前向迭代器   读写操作并向前推进迭代器
                     双向迭代器    读写操作，并能向前和向后操作
                     随机访问迭代器   读写操作，可以跳跃访问任意数据
# 模板
 模板就是建立通用的模具，提高复用性。
 ## 函数模板
  c++中另一种编程思想为泛型变成，主要利用的技术就是模板。
  c++中提供两种模板机制：函数模板和类模板
### 函数模板语法

       函数模板语法: 
          template<typename T>
           函数声明或定义

             template    声明创建模板
             typename   其后面跟着的是一种数据类型，可以用class代替
             T   通用的数据类型


            函数模板有两种使用方式:
               1.自动类型推导
               2.显示指定类型

```cpp
//函数模板
template <typename T> //后面的T是一个通用数据类型，告诉编译器不要报错
void mySwap(T &a,T &b){
   T temp=a;
   a=b;
   b=temp;
}
int main(){
    int a=10;
    int b=20;
//1.自动类型推导
    //mySwap(a,b);
//2. 显示指定类型
    //  mySwap<int>(a,b);
    cout <<a<<endl;
    cout << b<<endl;
    system("pause");
    return 0;
}
```
### 注意事项
   自动类型推导，必须推导出一致的数据类型T，才可以使用。
   模板必须要确定出T的数据类型，才可以使用、

```cpp
//函数模板demo 
/**
   实现通用对数组进行排序的函数
   规则：升序
   算法：快排
   测试  char 数组，int数组
 */
//交换函数
template <class T> //后面的T是一个通用数据类型，告诉编译器不要报错,typename可以用calss代替
void mySwap(T &a, T &b)
{
    T temp = a;
    a = b;
    b = temp;
}
//排序函数
template <class T>
void mySort(T arr[], int length)
{
    for (int i = 0; i < length; i++)
    {
        int min = i; //基准
        for (int j = i + 1; j < length; j++)
        {
            if (arr[min] > arr[j])
            {
                min = j;
            }
        }
        if (i != min)
        {
            mySwap(arr[i], arr[min]);
        }
    }
}
//输出函数
template <class T>
void myPrint(T arr[], int len)
{
    for (int i = 0; i < len; i++)
    {
        cout << arr[i] << endl;
    }
}
void test01()
{
    //字符数组
    char arr[] = "bcdeaf";
    int len = sizeof(arr) / sizeof(arr[0]);
    mySort(arr, len);
    myPrint(arr, len);
}
void test02()
{
    int arr[] = {6, 7, 3, 2, 10, 8};
    int len = sizeof(arr) / sizeof(arr[0]);
    mySort(arr, len);
    myPrint(arr, len);
}
int main()
{
    test01();
    test02();
    system("pause");
    return 0;
}
```
### 普通函数与函数模板的区别
 普通函数调用时可以发生自动类型转换(隐式类型转换)
 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换
 如果利用显示指定类型，可以发生自动类型推导
 ### 普通函数与函数模板的调用规则
   如果普通函数和模板函数都可以实现，优先调用普通函数
   可以通过空模板参数列表来强制调用函数模板
   函数模板也可以发生重载
   如果函数模板可以产生更好的匹配，优先调用函数模板。
### 模板的局限性
  模板并不是万能的
  ## 类模板
    建立一个通用类，类中的成员数据类型可以不具体制定，用一个虚拟的类型来代表。
    类模板和函数模板的语法相似，在template语句下写一个类，就是类模板
```cpp
template <class nameType,class ageType> //后面的T是一个通用数据类型，告诉编译器不要报错,typename可以用calss代替
class Person{
   public :
      nameType name;
      ageType  age;
     Person(nameType name,ageType age){
        this->name=name;
        this->age=age;
     }
    void showInfo(){
        cout << name << age <<endl;
     } 
};
int main()
{
    Person<string,int> p1("Tom",19);
    p1.showInfo();
    system("pause");
    return 0;
}
```
### 类模板与函数模板的区别
      类模板没有自动类型推导的使用方式
      类模板在模板参数列表中可以有默认参数
```cpp
#include <iostream>
using namespace std;
#include <string>
template <class nameType=string,class ageType=int>//默认参数
class Person{
   public :
      nameType name;
      ageType  age;
     Person(nameType name,ageType age){
        this->name=name;
        this->age=age;
     }
    void showInfo(){
        cout << name << age <<endl;
     } 
};
int main()
{
    Person<string> p("tim",20); 
    p.showInfo();
    Person<string,int> p1("Tom",19);
    p1.showInfo();
    system("pause");
    return 0;
}
```
### 类模板中成员函数创建时机 
   普通类中的成员函数一开始就可以创建，
   类模板中的函数在调用时才创建
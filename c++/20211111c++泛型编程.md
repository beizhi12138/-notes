# 模板
 模板就是建立通用的模具，提高复用性。
 ## 函数模板
  c++中另一种编程思想为泛型编程，主要利用的技术就是模板。
  c++中提供两种模板机制：函数模板和类模板
### 函数模板语法

       函数模板语法: 
          template<typename T>
           函数声明或定义

             template    声明创建模板
             typename   其后面跟着的是一种数据类型，可以用class代替
             T   通用的数据类型


            函数模板有两种使用方式:
               1.自动类型推导
               2.显示指定类型

```cpp
//函数模板
template <typename T> //后面的T是一个通用数据类型，告诉编译器不要报错
void mySwap(T &a,T &b){
   T temp=a;
   a=b;
   b=temp;
}
int main(){
    int a=10;
    int b=20;
//1.自动类型推导
    //mySwap(a,b);
//2. 显示指定类型
    //  mySwap<int>(a,b);
    cout <<a<<endl;
    cout << b<<endl;
    system("pause");
    return 0;
}
```
### 注意事项
   自动类型推导，必须推导出一致的数据类型T，才可以使用。
   模板必须要确定出T的数据类型，才可以使用、

```cpp
//函数模板demo 
/**
   实现通用对数组进行排序的函数
   规则：升序
   算法：快排
   测试  char 数组，int数组
 */
//交换函数
template <class T> //后面的T是一个通用数据类型，告诉编译器不要报错,typename可以用calss代替
void mySwap(T &a, T &b)
{
    T temp = a;
    a = b;
    b = temp;
}
//排序函数
template <class T>
void mySort(T arr[], int length)
{
    for (int i = 0; i < length; i++)
    {
        int min = i; //基准
        for (int j = i + 1; j < length; j++)
        {
            if (arr[min] > arr[j])
            {
                min = j;
            }
        }
        if (i != min)
        {
            mySwap(arr[i], arr[min]);
        }
    }
}
//输出函数
template <class T>
void myPrint(T arr[], int len)
{
    for (int i = 0; i < len; i++)
    {
        cout << arr[i] << endl;
    }
}
void test01()
{
    //字符数组
    char arr[] = "bcdeaf";
    int len = sizeof(arr) / sizeof(arr[0]);
    mySort(arr, len);
    myPrint(arr, len);
}
void test02()
{
    int arr[] = {6, 7, 3, 2, 10, 8};
    int len = sizeof(arr) / sizeof(arr[0]);
    mySort(arr, len);
    myPrint(arr, len);
}
int main()
{
    test01();
    test02();
    system("pause");
    return 0;
}
```
### 普通函数与函数模板的区别
 普通函数调用时可以发生自动类型转换(隐式类型转换)
 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换
 如果利用显示指定类型，可以发生自动类型推导
### 普通函数与函数模板的调用规则
   如果普通函数和模板函数都可以实现，优先调用普通函数
   可以通过空模板参数列表来强制调用函数模板
   函数模板也可以发生重载
   如果函数模板可以产生更好的匹配，优先调用函数模板。
### 模板的局限性
  模板并不是万能的
## 类模板
建立一个通用类，类中的成员数据类型可以不具体制定，用一个虚拟的类型来代表。
类模板和函数模板的语法相似，在template语句下写一个类，就是类模板
```cpp
template <class nameType,class ageType> //后面的T是一个通用数据类型，告诉编译器不要报错,typename可以用calss代替
class Person{
   public :
      nameType name;
      ageType  age;
     Person(nameType name,ageType age){
        this->name=name;
        this->age=age;
     }
    void showInfo(){
        cout << name << age <<endl;
     } 
};
int main()
{
    Person<string,int> p1("Tom",19);
    p1.showInfo();
    system("pause");
    return 0;
}
```
### 类模板与函数模板的区别
类模板没有自动类型推导的使用方式
类模板在模板参数列表中可以有默认参数
```cpp
#include <iostream>
using namespace std;
#include <string>
template <class nameType=string,class ageType=int>//默认参数
class Person{
   public :
      nameType name;
      ageType  age;
     Person(nameType name,ageType age){
        this->name=name;
        this->age=age;
     }
    void showInfo(){
        cout << name << age <<endl;
     } 
};
int main()
{
    Person<string> p("tim",20); 
    p.showInfo();
    Person<string,int> p1("Tom",19);
    p1.showInfo();
    system("pause");
    return 0;
}
```
### 类模板中成员函数创建时机 
   普通类中的成员函数一开始就可以创建，
   类模板中的函数在调用时才创建
```cpp
#include <iostream>
using namespace std;
#include <string>
class p1{
    public :
     void showInfo(){
        cout << "p1SowInfo" <<endl;
     }
};
class p2{
    public:
      void showInfo2(){
        cout << "p2showInfo"<<endl;
      }
};
template <class T>//默认参数
class Person{
   public :
   T obj;
   void func1(){
     obj.showInfo();
   } 
   void func2(){
       obj.showInfo2();
   }
};
int main()
{
    p1 p;
    Person<p1> p3;
    p3.func1();
    //p3.func2(); 在调用时才被创建
    system("pause");
    return 0;
}
```
### 类模板对象做函数参数
 类模板实例化出的对象，向函数传参的方式

    指定传入的类型  直接显示对象的数据类型
    参数模板化      将对象中的参数做为模板进行传递
    整个类模板化    将这个对象类型模板化进行传递

    最常用的是指定传入类型
```cpp
#include <iostream>
using namespace std;
#include <string>
template <class T, class T2> //默认参数
class Person
{
public:
    T name;
    T2 age;
    Person(T name, T2 age)
    {
        this->name = name;
        this->age = age;
    }
    void toString()
    {
        cout << this->name << this->age << endl;
    }
};
//指定传入类型
void printPerson(Person<string, int> &p)
{

    p.toString();
}
void test01()
{
    Person<string, int> p("Tom", 18);
    //类模板做函数参数
    printPerson(p);
}
//参数模板化
template <class T, class T2>
void printPerson2(Person<T, T2> &p)
{
    p.toString();
    cout << "T  type" << typeid(T).name() << endl;
    cout << "T1  type" << typeid(T2).name() << endl;
}
void test02()
{
    Person<string, int> p("zhangsan", 20);
    //类模板做函数参数
    printPerson2(p);
}
//整个类模板化
template <class T>
void printPerson3(T &p)
{
    p.toString();
    cout << "T type" << typeid(T).name() << endl;
}
void test03()
{
    Person<string, int> p("lisi", 56);
    printPerson3(p);
}
int main()
{
    test01();
    test02();
    test03();
    system("pause");
    return 0;
}
```
### 类模板与继承
   当子类继承的父类是一个类模板时，子类在声明的时候要指定出父类中T 的类型
   如果不指定，编译器无法给子类分配内存
   如果想灵活指定出父类中T 的类型，子类也需要变为类模板

```cpp

template <class T, class T2> //默认参数
class Person
{
public:
    Person()
    {
        cout << "T type" << typeid(T).name() << endl;
        cout << "T2 type" << typeid(T2).name() << endl;
    }
};
//必须指定出父类类型
class Son : public Person<int, char>
{
};
//灵活运行，子类必须也是一个类模板
template <class T1, class T, class T2>
class Son2 : public Person<T, T2>
{
public:
    Son2()
    {
        cout << "T type" << typeid(T).name() << endl;
        cout << "T2 type" << typeid(T2).name() << endl;
        cout << "T1 type" << typeid(T1).name() << endl;
    }
};
void test01()
{
    Son s;
    Son2<int, char, double> s2;
}

int main()
{
    test01();
    system("pause");
    return 0;
}
```
### 类模板成员函数类外实现

```cpp
template <class T, class T2> //默认参数
class Person
{
public:
    Person(T name, T2 age);
    T name;
    T2 age;
    void  toString();
};
//成员函数类外实现
template <class T, class T2> 
Person<T,T2>::Person(T name,T2 age)
{
    this->name = name;
    this->age = age;
}
template <class T, class T2> 
void Person<T,T2>::toString(){
  cout << this->name << this->age <<endl;
}
void test01()
{
    Person<string,int> p("Tom",18);
    p.toString();
}

int main()
{
    test01();
    system("pause");
    return 0;
}
```
### 类模板分文件编写
  类模板中成员函数的创建时机是在调用阶段，导致分文件编写时链接不到。

    解决方式1：直接包含.cpp源文件
    解决方式2: 将声明和实现写到同一个文件中，并更改后缀名为.hpp,hpp是约定的名称
```cpp
#include <iostream>
using namespace std;
#include <string>
//第一种解决方式直接引入源文件,还是正常的分文件编写，但是在引入的时候直接引入源文件
//#include "./lib/Person.cpp"
//第二种解决方式,将声明和实现写在同一个文件中，文件后缀为hpp ,推荐用第二种方式
#include "./includes/Person.hpp"
void test01()
{
    Person<string,int> p("Tom",18);
    p.toString();
}

int main()
{
    test01();
    system("pause");
    return 0;
}
```
### 类模板与友元
  全局函数类内实现，直接在类内声明友元即可
  全局函数类外实现，需要提前让编译器知道全局函数的存在

```cpp
template <class T1,class T2>
class Person;
//全局函数类外实现
template <class T1,class T2>
void printPerson2(Person<T1,T2> p){
    //如果是全局函数类外实现，需要让编译器提前知道有这个函数
     cout << p.name <<p.age<<endl;
};
template <class T1,class T2>
class Person{
    //全局函数类内实现
   friend void printPerson(Person<T1,T2> p){
        cout << p.name <<p.age<<endl;
    }
    //全局函数类外实现 ,
    // 加空参数模板列表
    // 如果全局函数是类外实现，需要让编译器提前知道有这个函数存在
    friend void printPerson2<>(Person<T1,T2> p); 
    public:
     Person(T1 name,T2 age){
           this->name=name;
           this->age=age;
     };
    private :
      T1 name;
      T2  age;
};

void test01()
{
    Person<string,int> p("Tom",18);
    printPerson(p);
    printPerson2(p);
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
```cpp
//类模板案例
/**
  实现一个通用的模板类
    可以对内置的数据类型，也可以对自定义数据类型进行存储
    将数组中的数据存储到堆去
    构造函数中可以传入数组的容量
    提供对应的拷贝构造函数以及operator=防止浅拷贝问题
     提供push 和pop方法对数组增删
     可以通过下标访问数组中的元素
     可以获取length和数组的容量
 */

 //Array.hpp
 #pragma once
#include <iostream>
using namespace std;
template <class T>
class Array
{
private:
    T *arrAddress; //开辟在堆区的真实数组
    int length;    //数组元素的个数
    int size;      //数组的容量
public:
    // 有参构造，设置数组的容量，以及初始化属性
    Array(int size)
    {
        this->size = size;
        this->length = 0;
        this->arrAddress = new T[this->size];
    }
    //拷贝构造函数
    Array(const Array &arr)
    {
        this->size = arr.size;
        this->length = arr.length;
        //重新开辟内存空间，防止堆区数据重复释放
        this->arrAddress = new T[arr.size];
        //如果有数据将数据放进去
        for (int i = 0; i < this->length; i++)
        {
            this->arrAddress[i] = arr.arrAddress[i];
        }
    }
    //重载=运算符
    Array &operator=(const Array & arr)
    { 
       //先判断原来的堆区是否有数据，有则释放干净
       if (this->arrAddress != NULL) {
         delete [] this->arrAddress;
         this->arrAddress=NULL;
         this->size=0;
         this->length=0;
       }   
       this->size=arr.size;
       this->length=arr.length;
       this->arrAddress=new T[arr.size];
       //拷贝过来原来的数据
       for(int i=0;i<this->length;i++){
        this->arrAddress[i]=arr.arrAddress[i];
       }
       //返回当前对象
       return *this;
    }
    //析构函数
    ~Array()
    {
        if (this->arrAddress != NULL)
        {
            delete[] this->arrAddress;
            this->arrAddress = NULL;
        }
    }
    //push方法
    void push(T val){
      if(this->size == this->length){
        return;
      }
      this->arrAddress[this->length]=val;
      this->length++;
    }
    //pop方法
    void pop(){
          if(this->length == 0){
            return;
          }
           this->length--;
    }
    //重写[] 利于arr[i]这样访问
    //返回引用以便于重新赋值
    T& operator[](int index){
          return this->arrAddress[index];
    }
    //返回length
    int get_Length(){
        return this->length;
    }
    //返回size
    int get_Size(){
        return this->size;
    }
};
//main函数
#include <iostream>
using namespace std;
#include <string>
#include "./includes/Array.hpp"
void printArr(Array<int> &arr){
  for(int i=0;i<arr.get_Length();i++){
    cout <<arr[i] <<endl;
  }
};
void test01()
{
   Array<int> arr1(5);
   for(int i=0;i<5;i++){

    arr1.push(i+1);
   }
   cout << "arr1"<<endl;
   printArr(arr1);
   cout << "arr1 length" << arr1.get_Length() <<endl;
   cout <<  "arr1 size" << arr1.get_Size()<<endl;
   Array<int> arr2(arr1);
   cout << "arr2"<<endl;
   arr2.pop();
   printArr(arr2);
   cout << "arr2 length" << arr2.get_Length() <<endl;
   cout <<  "arr2 size" << arr2.get_Size()<<endl;
};
//测试数组，存储自定义数据类型
class Person{
    public:
     int age;
     string name;
     Person(){}
     Person(int age,string name){
        this->age=age;
        this->name=name;
     }
};
void printPersonArr(Array<Person> & arr){
  for(int i=0;i<arr.get_Length();i++){
    cout << arr[i].name << arr[i].age <<endl;
  }
};
void test02(){
    Array<Person> arr(10);
    Person p1(20,"tom");
    Person p2(28,"tim");
    arr.push(p1);
    arr.push(p2);
    printPersonArr(arr);
}
int main()
{
    test01();
    test02();
    system("pause");
    return 0;
}
```
# STL常用容器
c++的面向对象和泛型变成思想，目的就是复用性的提升。但是数据结构和算法未能有一套标砖导致从事大量重复，为了建立数据结构和算法的一套标准，诞生了STL
## 基本概念
  STL从广义上分为:容器，算法，迭代器
  容器和算法之间通过迭代器进行无缝衔接
  STL几乎所有的代码都采用了模板类或者模板函数。

## STL六大组件
    STL大体分为六大组件分别是:容器。算法，迭代器，仿函数，适配器，空间配置器

        容器: 各种数据结构，list,queue,map等用来存放数据
        算法: 各种常用的算法，排序，查找，copy,遍历等
        迭代器:扮演了容器与算法之间的胶合剂
        仿函数: 行为类似函数，可作为算法的某种策略
        适配器:一种用来修饰容器或者仿函数或迭代器接口的东西。
        空间配置器: 负责空间的配置与管理


## STL容器，算法，迭代器
   STL容器运用最广泛的一些数据结构实现出来。

   常用的数据结构:数组，链表，栈，树，队列，集合，映射表等。

     容器分为  序列式容器:数组，队列，栈
               关联式容器: 链表，树

        算法分为质变算法和非质变算法
             质变算法: 运算过程中会更改区间内的元素的内容，例如替换，删除等
             非质变算法:是指运算过程中不会更改区间的元素内容，例如查找，遍历等

             迭代器:提供一种方法，使之能够依序访问某个容器所含的各个元素，每个容器都有自己的迭代器。
             迭代器非常类似于指针。

                 迭代器有五种

                     输入迭代器  对数据只读
                     输出迭代器  对数据只写
                     前向迭代器   读写操作并向前推进迭代器
                     双向迭代器    读写操作，并能向前和向后操作
                     随机访问迭代器   读写操作，可以跳跃访问任意数据

### 容器算法迭代器初识
  STL中最常用的容器是Vector,可以理解为数组。

```cpp
//for_each的回调
void func(int val){
 cout << val <<endl;
}
int main()
{
    vector<int> v;//创建这个容器
    v.push_back(10);//添加内容
    v.push_back(20);
    v.push_back(30);
    v.push_back(40);
    v.push_back(50);
    v.push_back(60);
    //通过迭代器访问
    // vector<int>::iterator pBegin=v.begin(); //这里的begin是一个指针，指向的是容器第一个元素的位置
    // vector<int>::iterator pEnd=v.end();//end也是一个指针，指针指向的是容器中最后一个元素的位置
    // //第一种遍历方式
    // while(pBegin != pEnd){
    //     cout << *pBegin <<endl;
    //     pBegin++;//移动到下一个元素的位置
    // }
    //第二种遍历方式
    // for( vector<int>::iterator pBegin=v.begin();pBegin!= v.end() ; pBegin++){
    //      cout << *pBegin<<endl;
    // }
    //通过标准算法库来进行访问
    vector<int>::iterator pBegin=v.begin(); 
    vector<int>::iterator pEnd=v.end();
    for_each(pBegin,pEnd,func);//接受三个参数，begin,end,回调函数(回调函数的参数就是容器中每一个元素的值)
    system("pause");
    return 0;
}
```
```cpp
 //vector容器，存放自定义数据类型
 #include <iostream>
using namespace std;
#include <string>
#include <vector>    //引入容器的头文件
#include <algorithm> //标准算法库的头文件
class Person
{
public:
    string name;
    int age;
    Person(string name, int age)
    {
        this->name = name;
        this->age = age;
    }
};
//添加自定义数据类型
void test01(){
    Person p1("aaa",20);
    Person p2("bbb",22);
    Person p3("ccc",23);
    Person p4("ddd",24);
    Person p5("eee",25);
    Person p6("fff",26);
    vector<Person> v;
    v.push_back(p1);
    v.push_back(p2);
    v.push_back(p3);
    v.push_back(p4);
    v.push_back(p5);
    v.push_back(p6);
    //进行遍历访问
    for(vector<Person>::iterator pBegin=v.begin();pBegin != v.end();pBegin++){
           cout << (*pBegin).name <<endl;
           cout << pBegin->age<<endl;//PBegin 是一个指针，直接通过->拿到数据
    }
}
//存放自定义数据类型指针
void test02(){
 Person p1("aaa",20);
    Person p2("bbb",22);
    Person p3("ccc",23);
    Person p4("ddd",24);
    Person p5("eee",25);
    Person p6("fff",26);
    vector<Person *> v;
    v.push_back(&p1);
    v.push_back(&p2);
    v.push_back(&p3);
    v.push_back(&p4);
    v.push_back(&p5);
    v.push_back(&p6);
    //进行遍历访问
    for(vector<Person *>::iterator pBegin=v.begin();pBegin != v.end();pBegin++){
      cout << (* pBegin)->name << " " << (* pBegin)->age <<endl;
     }
}

int main()
{
    test01(); 
    test02();
    system("pause");
    return 0;
}
```
### 容器嵌套容器
 容器嵌套容器就是，一个大容器里再嵌套多个小容器

```cpp
void test01()
{
    //创建一个大容器
    vector<vector<int>> bigV;
    //创建四个小容器
    vector<int> smallV1;
    vector<int> smallV2;
    vector<int> smallV3;
    vector<int> smallV4;
    //循环向小容器里添加数据
    for (int i = 0; i < 4; i++)
    {
        smallV1.push_back(i + 1);
        smallV2.push_back(i + 2);
        smallV3.push_back(i + 3);
        smallV4.push_back(i + 4);
    }
    //将小容器添加进小容器里
    bigV.push_back(smallV1);
    bigV.push_back(smallV2);
    bigV.push_back(smallV3);
    bigV.push_back(smallV4);
    //遍历大容器数据
    for(vector<vector<int>>::iterator it=bigV.begin(); it != bigV.end();it++){
       //遍历小容器的数据
       for(vector<int>::iterator sIt=(* it).begin();sIt!=(* it).end();sIt++){
        cout << (* sIt);
       }
       cout << endl;
    }
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
## string 容器
  string是c++风格的字符串，string本质上是一个类

  string  和 char *的区别
    char *是一个指针
    string  是一个类，类内部封装了char*,管理这个字符串


    string类内部封装了很多成员方法，增删改查。
### string的构造函数
  string(); 创建一个空的字符串
  string(const char * s) 使用字符串s 初始化
  string(const string& str) 使用一个string初始化另外一个string对象
  string(int n,char c) 使用n个字符c 初始化

```cpp
void test01()
{
  // string的构造函数
  //空构造
  string s1;
  cout << s1 <<endl;
  //使用char *构造
  const char * str="Hello World";
  string s2(str);
  cout << s2 <<endl;
  //使用一个string对象初始化另一个string
  string s3(s2);
  cout << s3 <<endl;
  //使用使用n个字符c初始化
  string s4(10,'a');
  cout << s4<<endl;
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### string容器-赋值操作
  string容器的赋值操作，既可以通过=操作(因为string类内部重写了=运算符),也可以通过成员函数assign操作

     赋值函数原型
       operator=(const char * s) || assign(const char * s)  char*类型字符串，赋值给当前的字符串

       operator=(const string s) 把字符串s赋值给当前字符串

       operator=(char c) 字符c赋值给当前字符串

       assign(const char * s,int n) 将s字符串的前n个字符赋值给当前的字符串

       assign(const string &s)    把s字符串赋值给当前字符串

       assign(int n,char c) 字符c赋值给当前字符串n次

```cpp
void test01()
{
  // string的赋值操作
  //空构造
  const char * str="Hello World";
  string s1;
  s1=str; //(operator=(const char *))
  cout << "s1 = "<<s1<<endl;
  string s2;
  s2.assign(str);// assign(const char *)
  cout << "s2 = "<<s2 << endl;
  string s3;
  string str1="Hello C++";
  s3=str1; // operator=(const string s)
  cout << "s3 = " << s3<<endl;
  string s4;
  s4='a';//operator=(char c)
  cout << "s4 = " << s4 <<endl;
  string s5;//assign(char * s ,int n)
  s5.assign(str,5);
  cout << "s5 = " << s5 <<endl;
  string s6;
  s6.assign(str1);
  cout << "s6 = "<< s6 <<endl;
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### 字符串拼接


      
        函数原型
          operator+=(const char *)；
          operator+=(const char c);
          operator+=(const string & str);
          append(char * s);
          append(const char * s,int n) 将s字符串的前n个字符拼接到当前字符串的末尾

          append(const string &s) 

          append(const string &s,int start,int end) 将字符s从start字符到end字符拼接到当前字符串

```cpp

void test01()
{
    //拼接字符串操作

    // operator+=(const char * str)
    string s1;
    const char *str = "Hello C++";
    s1 += str;
    cout << "s1 = " << s1 << endl;

    // operator+=(char c)

    string s2;
    char s = 'a';
    s2 += s;
    cout << "s2 = " << s2 << endl;

    // operator+=(const string & str)
    string s3;
    string str1 = "Hello World";
    s3 += str1;
    cout << "s3 = " << s3 << endl;

    // append(const char * s)
    string s4;
    const char * str2="Hello jingmao";
    s4.append(str2);
    cout << "s4 = " << s4 << endl;

    //append(const char * s ,int n)

    string s5;
    const char * str3="aaacccsa";
    s5.append(str3,6);
    cout << "s5 = " << s5 <<endl;

    // append(const string &s,int start,int end) 
    string str4="aaaaabbbbbsaeq2wqwe";
    string s6;
    s6.append(str4,6,9);
    cout << "s6 = " << s6 << endl;
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```

### string的查找和替换

 查找使用函数find 和rfind 
 替换使用函数replace

     
       
        函数原型

           find(const string & str,int pos =0)  查找str第一次出现的位置,pos是开始查找的位置

           find(const char * s,int pos,int n) 查找s的前n个字符第一次出现的位置

           find(cahr c,int pos=0); 查找字符c第一次出现的位置

           rfind(const string& str,int pos=最后一个字符的位置)  查找str最后一次出现的位置从pos开始找，pos默认是最后一个字符的位置

           rfind(const char * s,int pos,int n) 查找s的前n个字符最后一次出现的位置

           rfind(char c,int pos=0;) 查找字符c最后一次出现的位置

           replace(int pos,int n,const string & str)  替换从pos开始n个字符为字符串str
           
           replace(int pos,int n,const char * s) 替换从pos开始的n个字符为字符串s

```cpp
void test01()
{ 
    //查找字符串
    string str1="abcdefgde";
    cout << str1.find("de") <<endl;//找到返回下标找不到返回-1
    cout << str1.rfind("de")<<endl;//find是从左往右找，rfind是从右往左找
}
void test02(){
    //替换字符串
    string str1="abcdefga";
    str1.replace(1,3,"1111");
    cout << str1 <<endl;
}
int main()
{
    test01();
    test02();
    system("pause");
    return 0;
}
```
### 字符串比较
  字符串之间的比较是按照字符的ASCLL码进行对比

    相等返回0
    大于返回1
    小于返回-1

通过函数compare进行比较

```cpp
void test01()
{ 
    //比较字符串
    string str1="hellos";
    string str2="hello";
    int result=str1.compare(str2);
    if(result == 0){
        cout << "str1 == str2" <<endl;
    }else if(result == 1){
        cout << "str 1 > str2 " <<endl;
    }else{
        cout << "str1 < str2" <<endl;
    }
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### 获取字符
 可以通过[index] 方式获取字符
 可以通过 at(index) 方式获取字符

```cpp
 void test01()
{ 
    //读写字符串
    string str1="hellos";
    for(int i=0;i<str1.size();i++){
        cout << str1[i] <<" " <<str1.at(i) <<endl;
    }
    //修改单个字符
    str1[3]='x';
    cout << str1 <<endl;
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### 插入和删除字符
 对字符串进行插入和删除操作

    函数原型
       
        insert(int start,string s) 从start位置开始插入字符串s

        insert(int start,int n,char c) 在指定位置start插入n个字符c

        erase(int start,int n) 删除从start开始的n个字符
```cpp
void test01()
{ 
    //插入和删除字符
    string str1="hellos";
    str1.insert(0,10,'1');
    str1.insert(11,"World");
    str1.erase(0,11);
    cout  << str1 <<endl;
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### 截取字符串
  通过substr函数进行获取子串

  substr(int start=0,int num); 从start的位置开始截取num个字符

```cpp
void test01()
{ 
    //插入和删除字符
    string str1="hellos";
    cout << str1.substr(0,3) <<endl;
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
## vector容器
  vector容器的结构和数组非常相似，也称为单端数组

   vector和普通数组的区别:
      普通数组是静态空间，vector可以动态扩展

动态扩展并不是在原空间继续新接空间，而是找更大的内存空间，将原有的数据拷贝到新空间，释放原空间
### vector构造函数
 
     vector<T> v  采用模板类实现，默认构造函数

     vector(v.begin(),v.end()); 将begin和end区间中的元素拷贝给当前容器

     vector(n,elem)  拷贝n个elem给当前容器

     vector(const vector &vec) 拷贝构造函数

```cpp
void printVector(vector<int> &v){
    for(vector<int>::iterator it=v.begin();it!=v.end();it++){
           cout<<*it<<" ";
    }
  cout << endl;
}
void test01()
{ 
 //vector构造函数
   //默认构造
    vector<int> v;
    for(int i=1;i<=10;i++){
        v.push_back(i);
    }
    printVector(v);
   //区间构造
    vector<int> v2(v.begin(),v.end());
    printVector(v2);
    //n个elem构造
    vector<int> v3(10,100);
    printVector(v3);
    //拷贝构造函数
    vector<int> v4(v3);
    printVector(v4);
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### vector的赋值操作

     operator= 重载等号操作符

     assign(begin,end) 将begin至end区间的数据赋值给本身

     assign(n,elem) 将n个elem赋值给本身

```cpp
void printVector(vector<int> &v){
    for(vector<int>::iterator it=v.begin();it!=v.end();it++){
           cout<<*it<<" ";
    }
  cout << endl;
}
void test01()
{ 
 //赋值操作
    vector<int> v;
    for(int i=1;i<=10;i++){
        v.push_back(i);
    }
    printVector(v);
//operator=
    vector<int> v2;
    v2=v;
  printVector(v2);
//assign
    vector<int> v3;
    v3.assign(v2.begin(),v2.end());
    printVector(v3);

    v3.assign(10,100);
    printVector(v3);

}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### vector的容量和大小


     
      函数原型
         
          empty 判断容器是否为空

          capacity  容器的容量

          size 返回容器中元素的个数

          resize 重新指定容器的长度为num,若容器变长则以默认值重新填充默认位置

          resize(int num,elem) 重新指定容器的长度为num,若容器变长则以elem填充新的位置，如果容器变短则末尾超出容器长度的元素被删除



```cpp
void printVector(vector<int> &v){
    for(vector<int>::iterator it=v.begin();it!=v.end();it++){
           cout<<*it<<" ";
    }
  cout << endl;
}
void test01()
{ 
 //赋值操作
    vector<int> v;
    for(int i=1;i<=10;i++){
        v.push_back(i);
    }
  if(!v.empty()){
   cout << "v No NULL" <<endl;
   cout << "v Size" << v.size() <<endl;
   cout << "v Capacity" << v.capacity() << endl;
   v.resize(20,100); //重新指定大小,如果超出原来的容量,第二个参数如果不写，默认用0去填充剩余位置
    printVector(v);
    v.resize(5);//重新指定大小，如果比原来的容量小，那么会删除多余的元素
    printVector(v);
  }else{
    cout << "v is NULL" <<endl;
  }
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### vector插入和删除
   
     
       函数原型

        push_back
        
        pop_back
        
        insert(iterator start,ele) 向start位置插入ele
        
        insert(iterator start,int count,ele) 向start位置插入count个ele

        erase(iterator start)  删除start位置的元素

        erase(iterator start,iterator end) 删除从start到end位置的元素

        clear 删除容器中所有元素

```cpp
void printVector(vector<int> &v){
    for(vector<int>::iterator it=v.begin();it!=v.end();it++){
           cout<<*it<<" ";
    }
  cout << endl;
}
void test01()
{ 
 //赋值操作
    vector<int> v;
    //尾插
    v.push_back(10);
    v.push_back(20);
    v.push_back(30);
    v.push_back(40);
    v.push_back(50);
    v.push_back(60);
    printVector(v);
    //尾删
    v.pop_back();
    printVector(v);
    //插入
    v.insert(v.begin(),66);
    printVector(v);
    v.insert(v.begin(),2,1000);
    printVector(v);
    //删除
    v.erase(v.begin());
    printVector(v);
    // //清空
    v.clear();
    printVector(v);
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```

### vector数据存取

  
     at(int index)   返回index位置的元素
     operator[index]  返回index位置的元素
     front()  返回容器中第一个元素
     back()  返回容器中最后一个元素 

```cpp
void test01()
{ 
    //数据存取
    vector<int> v;
    v.push_back(10);
    v.push_back(20);
    v.push_back(30);
    v.push_back(40);
    v.push_back(50);
    v.push_back(60);
    for(int i=0;i<v.size();i++){
        //通过operator=和at函数访问
        cout <<v[i] << " "<< v.at(i) <<endl;
    }
    //front
    cout<< "one First" << v.front() <<endl;
    //back
    cout << "back" << v.back() <<endl;
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### 互换容器
 实现两个容器内元素进行互换

 通过swap函数进行互换

 巧用容器互换能够收缩内存
 

 ```cpp
void printVector(vector<int> &v)
{
    for (vector<int>::iterator it = v.begin(); it != v.end(); it++)
    {
        cout << *it << " ";
    }
    cout << endl;
}
void test01()
{
    //互换
    vector<int> v;
    vector<int> v2;
    for (int i = 0; i < 10; i++)
    {
        v.push_back(i);
    }
    for (int i = 9; i >= 0; i--)
    {
        v2.push_back(i);
    }
    //互换前
    cout << "swap before" << endl;
    printVector(v);
    printVector(v2);
    cout << "swap hou" << endl;
    v.swap(v2);
    printVector(v);
    printVector(v2);
}
//实际用途
//巧用swap缩短内存空间
void test02()
{
    vector<int> v;
    //向容器中插入100000个是数据
    for (int i = 0; i < 100000; i++)
    {
        v.push_back(i);
    }
    cout << "v size" << v.size() << endl;
    cout << "v capaCity" << v.capacity() << endl;
    /**
     * 此时v的元素个数为10万，容量为131072
     * 接下来缩短v的大小
     */
    v.resize(3);
    cout << "v size" << v.size() << endl;
    cout << "v capaCity" << v.capacity() << endl;
    /**
     * 此时v的容量缩小后，v的元素个数为3，容量为131072
     * v的元素个数没有那么多，但是却占了较大的内存空间，比较浪费!!!
     * 所以我们需要巧用swap函数进行缩短内存空间
    */
   vector<int>(v).swap(v);
    cout << "v size" <<v.size()<<endl;
    cout << "v capaCity"<<v.capacity()<<endl;
    /**
     * 经过互换后v的容量为3，v的元素个数为3
     * 
     * vector<int>(v).swap(v) 代码的解释
     * 
     * vector<int>(v) 相当于调用了拷贝构造函数创建了一个匿名对象
     *  将这个匿名对象的内容，和v容器的内容进行互换，互换之后匿名对象就成为了占很多内存的那个容器
     *    但是匿名对象在执行完之后就会被系统回收，所以多占的内存空间也被内存回收掉了
    */
}
int main()
{
    //互换
    // test01();
    test02();
    system("pause");
    return 0;
}
 ```

 ### vector预留空间
  减少vector在动态扩展容量时的扩展次数

  reserve(int len) 容器预留len个元素长度，预留位置不初始化，元素不可访问

```cpp
void test01()
{ 
    //预留空间
    vector<int> v;

    int num=0;//统计动态扩展的次数
    int * p=NULL;
    v.reserve(10000);//提前预留空间,因为动态扩展每次都需要去找新的空间去存储数据，如果提前预留一定的空间存储则不会过多的去重新找空间
    //向容器里添加10000个数据，
    for(int i=0;i<10000;i++){
        v.push_back(i);
        if(p != &v[0]){
           p=&v[0];
           num++;
        }
    }
    cout << num <<endl;
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
## deque容器
 deque容器也被称为双端队列

 就是既然可以进行后进先出，也可以进行先进先出。

 deque与vector的区别
   
    vector对于头部的插入删除效率低，数据量越大，效率越低。
    deque相对而言，对头部的插入速度会比vector快
    vector访问元素时的速度会比deque快(这和两者的内部实现有关)。
    

    deque的工作原理:
      deque内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据。
      中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间
### deque的构造函数
  
    
     deque<T> 默认构造
     
     deque(start,end) 将start至end的元素拷贝给自身
     
     deque(n,ele)  将n个elem拷贝给本身

     deque(const deque &deq) 拷贝构造函数

```cpp
void printDeque(const deque<int> &v)
{
     //加上const 使用迭代器，就是一个只读的迭代器，不能修改容器里的数据
    for (deque<int>::const_iterator it = v.begin(); it != v.end(); it++)
    {
        cout << *it << " ";
    }
    cout << endl;
}
void test01()
{
    //默认构造
    deque<int> d;
    for(int i=0;i<10;i++){
        d.push_back(i);
    }
    printDeque(d);
    //deque(start,end)
    deque<int> d2(d.begin(),d.end());
    printDeque(d2);
    //deque(10,100)
    deque<int> d3(10,100);
    printDeque(d3); 
    //拷贝构造函数
    deque<int> d4(d3);
    printDeque(d4);
}
int main()
{
    test01();
    system("pause");
    return 0;
} 
```
### deque赋值操作 
 
    
     函数原型

       operator=(const deque &deq) 重载等号

       assign(start,end) 将start至end区间的数据赋值给本身

       assign(n,elem) 将n个elem赋值给本身

```cpp
void printDeque(const deque<int> &v)
{
     //加上const 使用迭代器，就是一个只读的迭代器，不能修改容器里的数据
    for (deque<int>::const_iterator it = v.begin(); it != v.end(); it++)
    {
        cout << *it << " ";
    }
    cout << endl;
}
void test01()
{
    //赋值操作
    deque<int> d;
    for(int i=0;i<10;i++){
        d.push_back(i);
    }
    printDeque(d);
    //operator=
    deque<int> d2;
    d2=d;
    printDeque(d2);
    //assign(start,end)
    deque<int> d3;
    d3.assign(d2.begin(),d2.end());
    printDeque(d3);
    //assign(num,ele)
    deque<int> d4;
    d4.assign(10,100);
    printDeque(d4);
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### deque大小操作

     函数原型

        empty 判断容器是否为空

        size 元素个数

        resize(num,elem) 重新指定长度，
```cpp
void test01()
{
    //赋值操作
    deque<int> d;
    for(int i=0;i<10;i++){
        d.push_back(i);
    }
    if(!d.empty()){
       cout << "d No NULL" <<endl;
       cout << "d size" << d.size() <<endl;;
    }else{
        cout << "d is NULL" <<endl;
    }
    //改变大小
    d.resize(20,1);//将长度扩展为20 ,多余用1代替
    printDeque(d);
   d.resize(5); //将长度缩短为5,多余的元素删除
    printDeque(d);
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### deque的插入和删除
   
    
     函数原型 
        push_back 
        
        pop_back
        
        push_front 头插
        
        pop_front 头删

        insert(start,elem) 在start位置插入elem,返回新数据的位置

        insert(start,n,elem) 在start位置插入n个elem，无返回值

        insert(pos,start,end)  在pos位置插入从start至end位置的数据无返回值

        clear() 清空容器

        erase(start,end) 删除start至end区间的数据，返回下一个数据的位置

        erase(start) 删除start位置的数据，返回下一个数据的位置

```cpp
void test01()
{
    //插入和删除
    deque<int> d;
    //插入
     d.push_back(10);
     d.push_back(20);
     d.push_front(100);
     d.push_front(200);
     printDeque(d);
    //删除
      d.pop_back();
      d.pop_front();
      printDeque(d);
    //insert
     d.insert(d.begin(),200);
     d.insert(d.end(),200);
     d.insert(d.begin(),3,1000);
     d.insert(d.begin(),d.begin(),d.end());
     printDeque(d);
     //erase
     d.erase(d.begin());
     printDeque(d);
     //clear
     d.clear();
     printDeque(d);

}
int main()
{
    test01();
    system("pause");
    return 0;
}
```

### deque的数据存取
  
     函数原型
       at(index)
       operator[index]
       front
       back
```cpp
void test01()
{
    //数据存取
    deque<int> d;
    //插入
     d.push_back(10);
     d.push_back(20);
     d.push_front(100);
     d.push_front(200);
    //读数据
    cout << d.front() <<endl;
    cout << d.back() <<endl;
    cout << d[0] <<endl;
    cout << d.at(0) <<endl;
    //修改数据
    d[0]=1000;
    cout << d[0] <<endl;
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### deque排序
 利用算法实现对deque容器进行排序

 算法: 
   sort(start,end)

```cpp
void test01()
{
    //数据存取
    deque<int> d;
    //插入
     d.push_back(10);
     d.push_back(1000);
     d.push_back(20);
     d.push_front(200);
     d.push_front(600);
     cout << "sort beigin" <<endl;
     printDeque(d);
     cout << "sort end" <<endl;
     sort(d.begin(),d.end());
     printDeque(d);
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
```cpp
/**
   vector容器和deque容器实战

   评委打分
     创建五名选手，放到Vector中
     遍历vector容器，取出来一个选手进行for循环，把10个评分放入到deque容器中
     sort算法对deque进行排序，去除最低分和最高分
     过滤一遍deque，累加总分
 */
 #include <iostream>
using namespace std;
#include <string>
#include <deque>
#include <algorithm>
#include <vector>
#include <ctime> //系统时间
class Person
{
public:
    string name;
    int source;
    Person(string name)
    {
        this->name = name;
    }
    void showInfo()
    {
        cout << this->name << " " << this->source << endl;
    }
};
void createPerson(vector<Person> &v)
{
    string names = "ABCDE";
    for (int i = 0; i < names.size(); i++)
    {
        string name = "xs";
        name += names[i];
        Person p(name);
        v.push_back(p);
    }
};
void sourcePerson(vector<Person> &v)
{
    //遍历五位选手
    for (vector<Person>::iterator it = v.begin(); it != v.end(); it++)
    {
        //创建deque容器用于存储分数
        deque<int> d;
        //循环10次，用随机数模拟法分数
        for (int i = 0; i < 10; i++)
        {
            //随机数代替100,取0-40的随机数最后再加60
            int source = rand() % 41 + 60;
            //将随机数放入deque
            d.push_back(source);
        }
        //去掉一个最高分，去掉一个最低分
        //先用sort进行排序
        sort(d.begin(), d.end());
        d.pop_back();
        d.pop_front();
        //显示一下随机数
        // cout << (*it).name << endl;
        // for (deque<int>::iterator dit = d.begin(); dit != d.end(); dit++)
        // {
        //     cout << *dit << " ";
        // }
        // cout << endl;

        //计算平均分
        int zongSource=0;
        for(deque<int>::iterator dit = d.begin(); dit != d.end();dit++){
            zongSource+=(*dit);
        }
        int source=zongSource/d.size();

        //将平均分赋值给选手
        (*it).source=source;
       
    }
}
void printVector(vector<Person> &v)
{
    for (vector<Person>::iterator it = v.begin(); it != v.end(); it++)
    {
        (*it).showInfo();
    }
}
int main()
{
    srand((unsigned int)time(NULL)); //随机数种子,用随机数种子让程序根据系统时间获取所记述
     // 创建五名选手放到vector容器中
    vector<Person> v;
    //创建五位选手
    createPerson(v);
    // 评委打分，并计算随机数
    sourcePerson(v);
    printVector(v);
    system("pause");
    return 0;
}
```
## stack容器
 stack就是栈，栈具有后进先出的特性。栈只能支持push(入栈),pop(出栈)的操作，栈不允许有遍历的行为。

### stack的常用方法

  构造函数
    
    stack<T> stk; 默认构造
    stack(stack)  拷贝构造函数

 数据存取

    push 向栈顶添加元素
    pop  从栈顶移除第一个元素
    top  返回栈顶元素

大小操作
 
    empty  判断栈是否为空
    size   返回栈的大小

赋值操作
   
    operator=

```cpp
void test01(){
    //默认构造
    stack<int> stk;

    //入栈
     stk.push(10);
     stk.push(20);
    //访问栈顶
    cout << stk.top() << endl;
    //栈的大小
    cout << stk.empty() <<endl;
    cout << stk.size()  <<endl;
    //出栈
    stk.pop();
    cout << stk.top()<<endl;//再次访问栈顶
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
## queue

  队列，队列具有先进先出的特性。
   队列中只有对头和队尾才可以被外界使用，因此队列不允许有遍历行为，队列有两种操作push(入队),pop(出队)。


### 队列的方法

构造函数
   
    queue<T> q; 默认构造
    queue(q) ;  拷贝构造函数

赋值操作

    operator= 

数据存取

    push 入队
    pop 出队
    back 返回最后一个元素
    front 返回第一个元素

大小操作
   
    empty  判断队列是否为空
    size   返回队列的大小

```cpp
void test01(){
    queue<int> q;//默认构造
    q.push(10);//入队
    q.push(20);//入队
    q.push(30);//入队
    queue<int> q1(q);//拷贝构造
    q.pop();//出队
    cout << q.back() << endl;//访问队尾
    cout << q.front() << endl; //访问队头 
    cout << q.size() <<endl;//访问队列的大小
}
int main()
{
    test01();
    system("pause");
    return 0;
}void test01(){
    queue<int> q;//默认构造
    q.push(10);//入队
    q.push(20);//入队
    q.push(30);//入队
    queue<int> q1(q);//拷贝构造
    q.pop();//出队
    cout << q.back() << endl;//访问队尾
    cout << q.front() << endl; //访问队头 
    cout << q.size() <<endl;//访问队列的大小
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
## list
  list就是链表，
  链表是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针实现的。


  链表是由一系列结点组成

  结点的组成:一个是存储数据元素的数据域。另一个是存储下一个节点地址的指针域。

### list的构造函数

    list<T> l;  默认构造
    
    list(start end); 将区间的值给本身
    
    list(n,ele);  n个ele
    
    list(l);  拷贝构造

```cpp
#include <list>
void printList(const list<int> &l){
 for(list<int>::const_iterator it=l.begin();it!=l.end();it++){
    cout << *it <<" ";
 }
 cout <<endl;
}
void test01(){
    list<int> l; //默认构造
    l.push_back(10);
    l.push_back(20);
    l.push_back(30);
    l.push_back(40);
    printList(l);
    list<int> l1(l.begin(),l.end()); //区间构造
    printList(l1);
    list<int> l3(10,100);//n个elem构造
    printList(l3);
    list<int> l2(l3);//拷贝构造
    printList(l2); 
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### list容器的赋值和交换

      函数原型
         assign(start,end); 区间赋值

         assign(n,elem)  n个elem

         operator=  重载=运算符

         swap 交换函数

```cpp
void printList(const list<int> &l){
 for(list<int>::const_iterator it=l.begin();it!=l.end();it++){
    cout << *it <<" ";
 }
 cout <<endl;
}
void test01(){
    list<int> l;
    l.push_back(10);
    l.push_back(20);
    l.push_back(30);
    l.push_back(40);
    printList(l);
    
    list<int> L2;
    L2=l; //operator=
    printList(L2);

    list<int> L3;
    L3.assign(4,100);//assign(n,elem)
    printList(L3);

    list<int> L4;
    L4.assign(L3.begin(),L3.end());
    printList(L4);

    //L4和L2交换
    cout << "swap before" <<endl;
    printList(L2);
    printList(L4);
    cout << "swap end" <<endl;
    L2.swap(L4);
    printList(L2);
    printList(L4);
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### list大小操作

    
    函数原型
       
       size 元素的个数
       
       empty  容器是否为空
       
       resize(num,elem=0) 重新指定容器长度
```cpp
void printList(const list<int> &l){
 for(list<int>::const_iterator it=l.begin();it!=l.end();it++){
    cout << *it <<" ";
 }
 cout <<endl;
}
void test01(){
    list<int> l;
    l.push_back(10);
    l.push_back(20);
    l.push_back(30);
    l.push_back(40);
    printList(l);
    cout << l.size() <<endl;
    cout << l.empty() <<endl;

    l.resize(20,100); //重新指定大小为20,默认值是100
    printList(l);
    l.resize(2);//重新指定大小为2
    printList(l);
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### list的插入和删除

     函数原型

        push_back 在容器尾部插入一个元素

        pop_back 删除容器最后一个元素

        push_front 在容器开头插入一个元素

        pop_front 在容器开头删除一个元素

        insert(start,elem) 在start位置插入一个elem

        insert(start,n,elem) 在start 位置插入n个elem

        insert(pos,start,end)  在pos位置插入区间元素

        clear()  清空容器

        erase(start,end) 删除区间元素

        erase(start) 删除start位置的元素

        remove(elem) 删除容器中所有与elem匹配的值

```cpp
void printList(const list<int> &l){
 for(list<int>::const_iterator it=l.begin();it!=l.end();it++){
    cout << *it <<" ";
 }
 cout <<endl;
}
void test01(){
    list<int> l;

    //头插
      l.push_front(10);
      l.push_front(20);
    //尾插
      l.push_back(100);
      l.push_back(200);
      printList(l);
    //去头和去尾
      l.pop_back();
      l.pop_front();
      printList(l);

      list<int>::iterator it=l.begin();

      //insert
        l.insert(++it,1000);
        printList(l);
        l.insert(++it,2,666);
        printList(l);
      //erase
        it=l.end();
        l.erase(--it);
        printList(l);
      //remove
        l.remove(666);
        printList(l);
        //clear
        l.clear();
        printList(l);
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### list数据存取
  front 返回第一个元素
  back 返回最后一个元素

### list容器中的反转和排序
  将容器中的元素反转，以及将容器中的数据进行排序。

    reverse 反转链表
    sort 排序链表


```cpp
bool myCompare(int val1,int val2){
  return val1>val2;
}
void test01(){
    list<int> l;
      l.push_front(10);
      l.push_front(20);
      l.push_back(100);
      l.push_back(200);
      cout << "reverse before" <<endl;
      printList(l);
      l.reverse();
      cout << "reverser end" <<endl;
      printList(l);

      //排序
        //所有不支持随机访问迭代器内容的容器，都不能使用标准算法库，但是他们的成员属性上回带有一些方法

        cout << "default sort "<<endl;
        l.sort();
        printList(l);

        cout << "diy sort" <<endl;
        l.sort(myCompare);
        printList(l);
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```

```cpp
 //链表排序案例
   /**
     Person自定义数据类型进行排序
     按照年龄进行升序，如果年龄相同进行降序
    */
    class Person{
    public:
      string name;
      int age;
      int height;
      Person(string name,int age,int height){
          this->name=name;
          this->age=age;
          this->height=height;
      }
};
void printList(const list<Person> &l){
 for(list<Person>::const_iterator it=l.begin();it!=l.end();it++){
    cout << "name : " << (*it).name <<" "<< " age " << (*it).age <<" " << " height : " << (*it).height <<endl;
 }
}
bool a(Person &p1,Person &p2){
  if(p1.age == p2.age){
    return p1.height > p2.height;
  }else{
  return p1.age < p2.age;
  }
}
void test01(){
    list<Person> l;
    //创建五个人
    Person p1("A",25,190);
    Person p2("B",40,170);
    Person p3("C",35,175);
    Person p4("D",45,166);
    Person p5("E",35,195);
    Person p6("F",35,190);
    //添加到list容器中
    l.push_back(p1);
    l.push_back(p2);
    l.push_back(p3);
    l.push_back(p4);
    l.push_back(p5);
    l.push_back(p6);
    cout << "sort before" <<endl;
    printList(l);
    cout << "sort end" <<endl;
    l.sort(a);
    printList(l);
} 
int main()
{
    test01();
    system("pause");
    return 0;
}
```
## Set/multiset
 Set就是集合
   所有元素在插入时会被自动排序

   set/multiset属于关联式容器，底层结构是用而二叉树实现

   set和multiset的区别
     set不允许容器中有重复的元素
     multiset 允许有重复的元素
### set的构造和赋值
     set<T> s;

     set() 拷贝构造

     operator= 赋值

```cpp
void printSet(const set<int> &s){
 for(set<int>::const_iterator it=s.begin();it!=s.end();it++){
    cout <<*it<<" ";
 }
 cout << endl;
}
void printMultiset(const multiset<int> &s){
 for(set<int>::const_iterator it=s.begin();it!=s.end();it++){
    cout <<*it<<" ";
 }
 cout << endl;
}
void test01(){
    //默认构造
  set<int> s;
  multiset<int> ms;
  s.insert(30);s.insert(10);  s.insert(20); //set不允许有重复的数据
  ms.insert(30);ms.insert(30);ms.insert(66);//multiset 允许有重复的数据
  printSet(s);
  printMultiset(ms);
  //拷贝构造
  set<int> s2(s);
  printSet(s);

  //赋值
  multiset<int> ms2;
  ms2=ms;
  printMultiset(ms2);
} 
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### 大小和交换

    函数原型
       size 返回容器中元素的个数

       empty 判断容器是否为空

       swap 交换两个集合容器
### 插入和删除

    insert(elem) 在容器中插入elem

    clear 清空所有元素

    erase(pos) 删除迭代器所指的元素

    erase(start,end) 删除区间元素

    erase(elem) 删除指定的elem

```cpp
void test01(){
  set<int> s;
  s.insert(30);s.insert(10);  s.insert(20); //插入
  cout << s.size() <<endl; // 元素个数
  cout << s.empty() << endl; //容器是否为空
  set<int> s2;
  s2.insert(20);s2.insert(30);s2.insert(60);
  cout << "swap before" <<endl;
  printSet(s);
  printSet(s2);
  cout << "swap end" << endl;
  s.swap(s2);
  printSet(s);
  printSet(s2);
   s.erase(20);//删除
   printSet(s);
  s2.clear();//清空
  printSet(s2);
  
} 
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### set查找和统计
   
    find(key) 查找key如果存在则返回key的迭代器，如果不存在则返回end();

    count(key) 统计key存在的个数
```cpp
void test01(){
  set<int> s;
  s.insert(30);s.insert(10);  s.insert(20);
  cout << *s.find(10) <<endl; //因为返回的是迭代器，而迭代器是一个指针需要用*去解析
  cout << s.count(10) <<endl;//count 对于set结果要么是0要么是1 对于multiset对于大于1
} 
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### set和multiset的区别

  set不可以重复插入数据，而multiset可以。

  set擦汗如数据的同时会返回插入结果，表示插入是否成功

  multiset不会检测数据，因此可以插入重复数据

### pair对组的创建
  成对出现的数据，利用对组可以返回两个数据

    pair<type,type> p(value1,value2)

    pair<type,type>=make_pair(value1,value2);

```cpp
void test01(){
  pair<int ,string> p(10,"tom");
  cout << p.first << p.second <<endl;
  pair<string , int> p1=make_pair("tom",20);
  cout << p1.first << p1.second <<endl;
} 
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### set的排序
 set容器默认是升序排序。

  利用仿函数可以改变排序规则。

  而且对于自定义数据类型set必须要自定义排序规则才可以插入

```cpp
class Person{
    public:
     string name;
     int age;
     Person(string name,int age){
        this->name=name;
        this->age=age;
     }
};
//利用仿函数自定义排序规则，因为仿函数的本质是一个类所以写一个类
class myCompare{
  public:
    bool operator()(const Person &p1,const Person &p2){
       return p1.age<p2.age;
   }
};
void test01(){
  Person p("A",20);
  Person p2("B",28);
  Person p3("C",18);
  set<Person,myCompare> s;
  s.insert(p);s.insert(p2);s.insert(p3);
  for(set<Person,myCompare>::iterator it=s.begin();it!=s.end();it++){
    cout << (*it).name << (*it).age<<endl;
  }
} 
int main()
{
    test01();
    system("pause");
    return 0;
}
```
## map / multimap
 map就是字典

  map中所有的元素都是pair。
  pair中的第一个元素为key,第二个元素为value

  map/multimap 属于关联式容器，底层结构是用二叉树实现

  优点:
    可以快速根据key值找到value值

 map和multimap的区别
   map不允许容器中有重复key值元素。
   multimap允许容器中有重复key值元素

### map的构造和赋值
   
      map<keyType,valType> m; 默认构造
      map(const map &map) 拷贝构造函数

      operator= 赋值

```cpp
void printMap(map<int, int> &m)
{
    for (map<int, int>::iterator it = m.begin(); it != m.end(); it++)
    {
        cout << "key" <<(*it).first << " value " << (*it).second <<endl;
    }
};
void test01()
{
    //默认构造
    map<int, int> m;
    m.insert(pair<int, int>(1, 10)); //插入数据的时候要用对组
    m.insert(pair<int, int>(2, 20));
    m.insert(pair<int, int>(3, 30));
    printMap(m);
    //拷贝构造
    map<int, int> m2(m);
    printMap(m2);
    //赋值
    map<int, int> m3;
    m3 = m2;
    printMap(m3);
};
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### map的大小和交换
   
    函数原型
       size 元素的个数
       empty 容器是否为空
       swap 交换

```cpp
void test01()
{
    map<int, int> m;
    m.insert(pair<int, int>(1, 10));
    m.insert(pair<int, int>(2, 20));
    m.insert(pair<int, int>(3, 30));
    cout << m.size()<<endl; //个数
    cout << m.empty() <<endl;
    map<int,int> m2;
    cout << "swap before" <<endl;
    m2.insert(pair<int, int>(10, 100));
    m2.insert(pair<int, int>(20, 200));
    m2.insert(pair<int, int>(30, 300));
        printMap(m);
        printMap(m2);
    cout << "swap end" <<endl;
        m.swap(m2);
        printMap(m);
        printMap(m2);
};
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### map插入和删除
  
     函数原型
       insert(elem) 在容器中插入元素

       clear 清空容器
       erase(pos) 删除pos迭代器所指的元素

       erase(start,end) 删除区间的元素

       erase(key) 删除指定key的元素

```cpp
void test01()
{
map<int,int> m;
//4种插入方式
 m.insert(pair<int,int>(1,20));
 m.insert(make_pair(2,30));
 m.insert(map<int,int>::value_type(3,56));
 //m[3]=66; //不建议使用，因为能通过key访问到value
 printMap(m);
 //删除
 m.erase(m.begin());
 printMap(m);
 //清空
 m.clear();
};
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### map查找和统计
  对map容器进行查找数据以及统计数据

     函数原型
       
       find(key) 返回value
       
       count(key) 对于map结果是0或1,

### map排序
  map排序默认是按照key升序。

  利用仿函数，可以改变排序规则。

```cpp
//map自定义排序规则且key为自定义数据类型
class Person
{
public:
    string name;
    int age;
    Person(string name, int age)
    {
        this->name = name;
        this->age = age;
    }
};
//自定义排序规则
class Mycompare{
    public:
    bool operator()(const Person &p1,const Person &p2){
         return p1.age < p2.age;
     }
};
void printMap(map<Person, int,Mycompare> &m)
{
    for (map<Person,int,Mycompare>::iterator it = m.begin(); it != m.end(); it++)
    {
        cout << "key" <<(*it).first.name << (*it).first.age <<endl;
    }
    cout<<endl;
};
void test01()
{
    Person p1("A",19);
    Person p2("B",20);
    Person p3("B",26);
    Person p4("B",18);
    Person p5("B",21);
    map<Person,int,Mycompare> m;
    m.insert(make_pair(p1, 30));
    m.insert(make_pair(p2, 30));
    m.insert(make_pair(p3, 30));
    m.insert(make_pair(p4, 30));
    m.insert(make_pair(p5, 30));
    printMap(m);
};
int main()
{
    test01();
    system("pause");
    return 0;
}
```
```cpp
//对vector容器和 map容器实战demo
#include <iostream>
using namespace std;
#include <string>
#include <map>
#include <vector>
#define CEHUA 0
#define MEISHU 1
#define KAIFA 2
class Worker
{
public:
    string name;
    int gz;
    Worker(string name, int gz)
    {
        this->name = name;
        this->gz = gz;
    }
};
void createWorker(vector<Worker> &v)
{
    string names = "ABCDEFGHIJ";
    for (int i = 0; i < names.size(); i++)
    {
        string name = "Worker";
        name += names[i];
        int gz = rand() % 10000 + 10000; // 工资是1w-19999
        Worker w(name, gz);
        v.push_back(w);
    }
}
//随机分配部门
void assignDepartments(vector<Worker> &v, multimap<int, Worker> &m)
{
    for (vector<Worker>::iterator it = v.begin(); it != v.end(); it++)
    {
        int bm = rand() % 3;
        m.insert(make_pair(bm, *it));
    }
}
//按照部门显示员工
void showWorker(multimap<int, Worker> &m)
{
    cout << "**********cehua***********" << endl;
    int count = m.count(CEHUA);
    int index = 0;
    multimap<int, Worker>::iterator it1 = m.find(CEHUA);
    for (; it1 != m.end() && index < count; index++, it1++)
    {
        cout << "bm : " << (*it1).first << " " << (*it1).second.name << " " << (*it1).second.gz << endl;
    }
    cout << "**********meishu***********" << endl;
    count = m.count(MEISHU);
    index = 0;
    it1 = m.find(MEISHU);
    for (; it1 != m.end() && index < count; index++, it1++)
    {
        cout << "bm : " << (*it1).first << " " << (*it1).second.name << " " << (*it1).second.gz << endl;
    }
    cout << "**********kaifa***********" << endl;
    count = m.count(KAIFA);
    index = 0;
    it1 = m.find(KAIFA);
    for (; it1 != m.end() && index < count; index++, it1++)
    {
        cout << "bm : " << (*it1).first << " " << (*it1).second.name << " " << (*it1).second.gz << endl;
    }
}
void test01()
{
    vector<Worker> v;
    multimap<int, Worker> m;
    //创建10个员工存储到vector容器中
    createWorker(v);
    // 随机分配部门,部门为键值，员工为key值
    assignDepartments(v, m);
    //按照显示员工
    showWorker(m);
};
int main()
{
    test01();
    system("pause");
    return 0;
}
```
# STL函数对象

## 函数对象
### 函数对象的概念
  重载函数调用操作符的类，其对象常称为函数对象。
  函数对象使用重载的()时，行为类似函数调用，也叫仿函数。

   函数对象(仿函数)是一个类，不是一个函数

### 函数对象的使用
  函数对象在使用时，可以像普通函数那样调用，可以有参数，可以有返回值
   函数对象超出普通函数的概念，函数对象可以有自己的状态。
   函数对象可以作为参数传递.

```cpp

class Myadd
{
public:
    int operator()(int val, int val2)
    {
        return val + val2;
    }
};
class Myprint
{
public:
    Myprint()
    {
        this->count = 0;
    }
    int count;
    void operator()(string test)
    {
        cout << test << endl;
        this->count++;
    }
};
//函数对象可以向普通函数一样调用,有参数,有返回值
void test01()
{
    Myadd myAdd;
    cout << myAdd(1, 2) << endl;
};
class doPrint
{
public:
    void operator()(Myprint &mp, string test)
    {
        mp(test);
    }
};
// 函数对象可以有自己的状态
void test02()
{
    Myprint myPrint;
    myPrint("Hello World");
    myPrint("Hello World");
    myPrint("Hello World");
    cout << "myPrint count " << myPrint.count << endl;
}
//函数对象可以作为参数传递
void test03()
{
    Myprint myPrint;
    doPrint Doprint;
    Doprint(myPrint,"Hello c++");
}
int main()
{
    test01();
    test02();
    test03();
    system("pause");
    return 0;
}
```
## 谓词
 返回bool类型的仿函数称为谓词.
### 一元谓词  
如果operator()接收一个参数,那么叫做一元谓词
```cpp
class GreaterFive{
    public:
    //返回值是bool,且只有一个参数的称为一元谓词
    bool operator()(int val){
       return val>5;
     }
};
void test01(){
  vector<int> v;
  for(int i=0;i<10;i++){
    v.push_back(i);
  }
  //find_if是标砖算符库 提供的条件查找算法
  // GreaterFive()是匿名函数对象
  vector<int>::iterator it=find_if(v.begin(),v.end(),GreaterFive());
  cout << *it <<endl;
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### 二元谓词 
如果operator()接收两个参数那么叫做二元谓词
```cpp
class Sort{
    public:
    //返回值是bool称为谓词,两个参数的称为二元谓词
    bool operator()(int val1,int val2){
           return val1>val2;
     }
};
void test01(){
  vector<int> v;
  v.push_back(30);
  v.push_back(20);
  v.push_back(66);
  cout << "sort  before" <<endl;
 for(vector<int>::iterator it=v.begin();it!=v.end();it++){
    cout << * it << " ";
 }
 cout <<endl;
 cout << "order by sort "<<endl;
 sort(v.begin(),v.end()); //默认升序
 for(vector<int>::iterator it=v.begin();it!=v.end();it++){
    cout << * it << " ";
 }
 cout <<endl;
 cout << "sort" <<endl;
 sort(v.begin(),v.end(),Sort());//使用函数对象改为降序
 for(vector<int>::iterator it=v.begin();it!=v.end();it++){
    cout << * it << " ";
 }
 cout <<endl;
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
## 内建函数对象
  内建函数对象就是STL提供了一些函数对象
    有三类:
        
          算数仿函数
          关系仿函数
          逻辑仿函数

    使用这些内建函数对象,需要引入头文件#include<functional>
## 算数仿函数
  实现了四则运算
  其中negate是一元运算,其他都是二元运算

     plus  加法仿函数
    
     minus 减法仿函数
     
     multiplies 减法仿函数
     
     divides 除法防函数

     modulus 取模仿函数

     negate 取反仿函数

```cpp
void test01(){
 //一元运算
  negate<int> n; //取反仿函数
  cout << n(50) <<endl;
 //二元运算
   plus<int> p; //加法防函数
   cout << p(10,20) <<endl;
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
## 关系仿函数
 实现关系对比
    
      仿函数原型
         equal_to 等于
         
         not_equal_to 不等于

         greater 大于

         greater_equal 大于等于

         less 小于

         less_equal 小于等于
```cpp
class Sort{
    public:
     bool operator()(int val1,int val2){
          return val1<val2;
      }
};
void test01(){
 vector<int> v;
 v.push_back(20);
 v.push_back(66);
 v.push_back(30);
 //自己实现的仿函数
 //sort(v.begin(),v.end(),Sort());
 //内建的仿函数
 sort(v.begin(),v.end(),greater<int>());
 for(vector<int>::iterator it=v.begin();it!=v.end();it++){
    cout << *it<< " ";
 }
 cout << endl;
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```

## 逻辑仿函数

      函数原型
         logical_and 与
         logical_or 或
         logincal_not 非

```cpp

```

# STL常用算法

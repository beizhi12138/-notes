# 模板
 模板就是建立通用的模具，提高复用性。
 ## 函数模板
  c++中另一种编程思想为泛型变成，主要利用的技术就是模板。
  c++中提供两种模板机制：函数模板和类模板
### 函数模板语法

       函数模板语法: 
          template<typename T>
           函数声明或定义

             template    声明创建模板
             typename   其后面跟着的是一种数据类型，可以用class代替
             T   通用的数据类型


            函数模板有两种使用方式:
               1.自动类型推导
               2.显示指定类型

```cpp
//函数模板
template <typename T> //后面的T是一个通用数据类型，告诉编译器不要报错
void mySwap(T &a,T &b){
   T temp=a;
   a=b;
   b=temp;
}
int main(){
    int a=10;
    int b=20;
//1.自动类型推导
    //mySwap(a,b);
//2. 显示指定类型
    //  mySwap<int>(a,b);
    cout <<a<<endl;
    cout << b<<endl;
    system("pause");
    return 0;
}
```
### 注意事项
   自动类型推导，必须推导出一致的数据类型T，才可以使用。
   模板必须要确定出T的数据类型，才可以使用、

```cpp
//函数模板demo 
/**
   实现通用对数组进行排序的函数
   规则：升序
   算法：快排
   测试  char 数组，int数组
 */
//交换函数
template <class T> //后面的T是一个通用数据类型，告诉编译器不要报错,typename可以用calss代替
void mySwap(T &a, T &b)
{
    T temp = a;
    a = b;
    b = temp;
}
//排序函数
template <class T>
void mySort(T arr[], int length)
{
    for (int i = 0; i < length; i++)
    {
        int min = i; //基准
        for (int j = i + 1; j < length; j++)
        {
            if (arr[min] > arr[j])
            {
                min = j;
            }
        }
        if (i != min)
        {
            mySwap(arr[i], arr[min]);
        }
    }
}
//输出函数
template <class T>
void myPrint(T arr[], int len)
{
    for (int i = 0; i < len; i++)
    {
        cout << arr[i] << endl;
    }
}
void test01()
{
    //字符数组
    char arr[] = "bcdeaf";
    int len = sizeof(arr) / sizeof(arr[0]);
    mySort(arr, len);
    myPrint(arr, len);
}
void test02()
{
    int arr[] = {6, 7, 3, 2, 10, 8};
    int len = sizeof(arr) / sizeof(arr[0]);
    mySort(arr, len);
    myPrint(arr, len);
}
int main()
{
    test01();
    test02();
    system("pause");
    return 0;
}
```
### 普通函数与函数模板的区别
 普通函数调用时可以发生自动类型转换(隐式类型转换)
 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换
 如果利用显示指定类型，可以发生自动类型推导
 ### 普通函数与函数模板的调用规则
   如果普通函数和模板函数都可以实现，优先调用普通函数
   可以通过空模板参数列表来强制调用函数模板
   函数模板也可以发生重载
   如果函数模板可以产生更好的匹配，优先调用函数模板。
### 模板的局限性
  模板并不是万能的
  ## 类模板
    建立一个通用类，类中的成员数据类型可以不具体制定，用一个虚拟的类型来代表。
    类模板和函数模板的语法相似，在template语句下写一个类，就是类模板
```cpp
template <class nameType,class ageType> //后面的T是一个通用数据类型，告诉编译器不要报错,typename可以用calss代替
class Person{
   public :
      nameType name;
      ageType  age;
     Person(nameType name,ageType age){
        this->name=name;
        this->age=age;
     }
    void showInfo(){
        cout << name << age <<endl;
     } 
};
int main()
{
    Person<string,int> p1("Tom",19);
    p1.showInfo();
    system("pause");
    return 0;
}
```
### 类模板与函数模板的区别
      类模板没有自动类型推导的使用方式
      类模板在模板参数列表中可以有默认参数
```cpp
#include <iostream>
using namespace std;
#include <string>
template <class nameType=string,class ageType=int>//默认参数
class Person{
   public :
      nameType name;
      ageType  age;
     Person(nameType name,ageType age){
        this->name=name;
        this->age=age;
     }
    void showInfo(){
        cout << name << age <<endl;
     } 
};
int main()
{
    Person<string> p("tim",20); 
    p.showInfo();
    Person<string,int> p1("Tom",19);
    p1.showInfo();
    system("pause");
    return 0;
}
```
### 类模板中成员函数创建时机 
   普通类中的成员函数一开始就可以创建，
   类模板中的函数在调用时才创建
```cpp
#include <iostream>
using namespace std;
#include <string>
class p1{
    public :
     void showInfo(){
        cout << "p1SowInfo" <<endl;
     }
};
class p2{
    public:
      void showInfo2(){
        cout << "p2showInfo"<<endl;
      }
};
template <class T>//默认参数
class Person{
   public :
   T obj;
   void func1(){
     obj.showInfo();
   } 
   void func2(){
       obj.showInfo2();
   }
};
int main()
{
    p1 p;
    Person<p1> p3;
    p3.func1();
    //p3.func2(); 在调用时才被创建
    system("pause");
    return 0;
}
```
### 类模板对象做函数参数
 类模板实例化出的对象，向函数传参的方式

    指定传入的类型  直接显示对象的数据类型
    参数模板化      将对象中的参数做为模板进行传递
    整个类模板化    将这个对象类型模板化进行传递

    最常用的是指定传入类型
```cpp
#include <iostream>
using namespace std;
#include <string>
template <class T, class T2> //默认参数
class Person
{
public:
    T name;
    T2 age;
    Person(T name, T2 age)
    {
        this->name = name;
        this->age = age;
    }
    void toString()
    {
        cout << this->name << this->age << endl;
    }
};
//指定传入类型
void printPerson(Person<string, int> &p)
{

    p.toString();
}
void test01()
{
    Person<string, int> p("Tom", 18);
    //类模板做函数参数
    printPerson(p);
}
//参数模板化
template <class T, class T2>
void printPerson2(Person<T, T2> &p)
{
    p.toString();
    cout << "T  type" << typeid(T).name() << endl;
    cout << "T1  type" << typeid(T2).name() << endl;
}
void test02()
{
    Person<string, int> p("zhangsan", 20);
    //类模板做函数参数
    printPerson2(p);
}
//整个类模板化
template <class T>
void printPerson3(T &p)
{
    p.toString();
    cout << "T type" << typeid(T).name() << endl;
}
void test03()
{
    Person<string, int> p("lisi", 56);
    printPerson3(p);
}
int main()
{
    test01();
    test02();
    test03();
    system("pause");
    return 0;
}
```
### 类模板与继承
   当子类继承的父类是一个类模板时，子类在声明的时候要指定出父类中T 的类型
   如果不指定，编译器无法给子类分配内存
   如果想灵活指定出父类中T 的类型，子类也需要变为类模板

```cpp

template <class T, class T2> //默认参数
class Person
{
public:
    Person()
    {
        cout << "T type" << typeid(T).name() << endl;
        cout << "T2 type" << typeid(T2).name() << endl;
    }
};
//必须指定出父类类型
class Son : public Person<int, char>
{
};
//灵活运行，子类必须也是一个类模板
template <class T1, class T, class T2>
class Son2 : public Person<T, T2>
{
public:
    Son2()
    {
        cout << "T type" << typeid(T).name() << endl;
        cout << "T2 type" << typeid(T2).name() << endl;
        cout << "T1 type" << typeid(T1).name() << endl;
    }
};
void test01()
{
    Son s;
    Son2<int, char, double> s2;
}

int main()
{
    test01();
    system("pause");
    return 0;
}
```
### 类模板成员函数类外实现

```cpp
template <class T, class T2> //默认参数
class Person
{
public:
    Person(T name, T2 age);
    T name;
    T2 age;
    void  toString();
};
//成员函数类外实现
template <class T, class T2> 
Person<T,T2>::Person(T name,T2 age)
{
    this->name = name;
    this->age = age;
}
template <class T, class T2> 
void Person<T,T2>::toString(){
  cout << this->name << this->age <<endl;
}
void test01()
{
    Person<string,int> p("Tom",18);
    p.toString();
}

int main()
{
    test01();
    system("pause");
    return 0;
}
```
### 类模板分文件编写
  类模板中成员函数的创建时机是在调用阶段，导致分文件编写时链接不到。

    解决方式1：直接包含.cpp源文件
    解决方式2: 将声明和实现写到同一个文件中，并更改后缀名为.hpp,hpp是约定的名称
```cpp
#include <iostream>
using namespace std;
#include <string>
//第一种解决方式直接引入源文件,还是正常的分文件编写，但是在引入的时候直接引入源文件
//#include "./lib/Person.cpp"
//第二种解决方式,将声明和实现写在同一个文件中，文件后缀为hpp ,推荐用第二种方式
#include "./includes/Person.hpp"
void test01()
{
    Person<string,int> p("Tom",18);
    p.toString();
}

int main()
{
    test01();
    system("pause");
    return 0;
}
```
### 类模板与友元
  全局函数类内实现，直接在类内声明友元即可
  全局函数类外实现，需要提前让编译器知道全局函数的存在

```cpp
template <class T1,class T2>
class Person;
//全局函数类外实现
template <class T1,class T2>
void printPerson2(Person<T1,T2> p){
    //如果是全局函数类外实现，需要让编译器提前知道有这个函数
     cout << p.name <<p.age<<endl;
};
template <class T1,class T2>
class Person{
    //全局函数类内实现
   friend void printPerson(Person<T1,T2> p){
        cout << p.name <<p.age<<endl;
    }
    //全局函数类外实现 ,
    // 加空参数模板列表
    // 如果全局函数是类外实现，需要让编译器提前知道有这个函数存在
    friend void printPerson2<>(Person<T1,T2> p); 
    public:
     Person(T1 name,T2 age){
           this->name=name;
           this->age=age;
     };
    private :
      T1 name;
      T2  age;
};

void test01()
{
    Person<string,int> p("Tom",18);
    printPerson(p);
    printPerson2(p);
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
```cpp
//类模板案例
/**
  实现一个通用的模板类
    可以对内置的数据类型，也可以对自定义数据类型进行存储
    将数组中的数据存储到堆去
    构造函数中可以传入数组的容量
    提供对应的拷贝构造函数以及operator=防止浅拷贝问题
     提供push 和pop方法对数组增删
     可以通过下标访问数组中的元素
     可以获取length和数组的容量
 */

 //Array.hpp
 #pragma once
#include <iostream>
using namespace std;
template <class T>
class Array
{
private:
    T *arrAddress; //开辟在堆区的真实数组
    int length;    //数组元素的个数
    int size;      //数组的容量
public:
    // 有参构造，设置数组的容量，以及初始化属性
    Array(int size)
    {
        this->size = size;
        this->length = 0;
        this->arrAddress = new T[this->size];
    }
    //拷贝构造函数
    Array(const Array &arr)
    {
        this->size = arr.size;
        this->length = arr.length;
        //重新开辟内存空间，防止堆区数据重复释放
        this->arrAddress = new T[arr.size];
        //如果有数据将数据放进去
        for (int i = 0; i < this->length; i++)
        {
            this->arrAddress[i] = arr.arrAddress[i];
        }
    }
    //重载=运算符
    Array &operator=(const Array & arr)
    { 
       //先判断原来的堆区是否有数据，有则释放干净
       if (this->arrAddress != NULL) {
         delete [] this->arrAddress;
         this->arrAddress=NULL;
         this->size=0;
         this->length=0;
       }   
       this->size=arr.size;
       this->length=arr.length;
       this->arrAddress=new T[arr.size];
       //拷贝过来原来的数据
       for(int i=0;i<this->length;i++){
        this->arrAddress[i]=arr.arrAddress[i];
       }
       //返回当前对象
       return *this;
    }
    //析构函数
    ~Array()
    {
        if (this->arrAddress != NULL)
        {
            delete[] this->arrAddress;
            this->arrAddress = NULL;
        }
    }
    //push方法
    void push(T val){
      if(this->size == this->length){
        return;
      }
      this->arrAddress[this->length]=val;
      this->length++;
    }
    //pop方法
    void pop(){
          if(this->length == 0){
            return;
          }
           this->length--;
    }
    //重写[] 利于arr[i]这样访问
    //返回引用以便于重新赋值
    T& operator[](int index){
          return this->arrAddress[index];
    }
    //返回length
    int get_Length(){
        return this->length;
    }
    //返回size
    int get_Size(){
        return this->size;
    }
};
//main函数
#include <iostream>
using namespace std;
#include <string>
#include "./includes/Array.hpp"
void printArr(Array<int> &arr){
  for(int i=0;i<arr.get_Length();i++){
    cout <<arr[i] <<endl;
  }
};
void test01()
{
   Array<int> arr1(5);
   for(int i=0;i<5;i++){

    arr1.push(i+1);
   }
   cout << "arr1"<<endl;
   printArr(arr1);
   cout << "arr1 length" << arr1.get_Length() <<endl;
   cout <<  "arr1 size" << arr1.get_Size()<<endl;
   Array<int> arr2(arr1);
   cout << "arr2"<<endl;
   arr2.pop();
   printArr(arr2);
   cout << "arr2 length" << arr2.get_Length() <<endl;
   cout <<  "arr2 size" << arr2.get_Size()<<endl;
};
//测试数组，存储自定义数据类型
class Person{
    public:
     int age;
     string name;
     Person(){}
     Person(int age,string name){
        this->age=age;
        this->name=name;
     }
};
void printPersonArr(Array<Person> & arr){
  for(int i=0;i<arr.get_Length();i++){
    cout << arr[i].name << arr[i].age <<endl;
  }
};
void test02(){
    Array<Person> arr(10);
    Person p1(20,"tom");
    Person p2(28,"tim");
    arr.push(p1);
    arr.push(p2);
    printPersonArr(arr);
}
int main()
{
    test01();
    test02();
    system("pause");
    return 0;
}
```
# STL
c++的面向对象和泛型变成思想，目的就是复用性的提升。但是数据结构和算法未能有一套标砖导致从事大量重复，为了建立数据结构和算法的一套标准，诞生了STL
## 基本概念
  STL从广义上分为:容器，算法，迭代器
  容器和算法之间通过迭代器进行无缝衔接
  STL几乎所有的代码都采用了模板类或者模板函数。

## STL六大组件
    STL大体分为六大组件分别是:容器。算法，迭代器，仿函数，适配器，空间配置器

        容器: 各种数据结构，list,queue,map等用来存放数据
        算法: 各种常用的算法，排序，查找，copy,遍历等
        迭代器:扮演了容器与算法之间的胶合剂
        仿函数: 行为类似函数，可作为算法的某种策略
        适配器:一种用来修饰容器或者仿函数或迭代器接口的东西。
        空间配置器: 负责空间的配置与管理


 ## STL容器，算法，迭代器
   STL容器运用最广泛的一些数据结构实现出来。

   常用的数据结构:数组，链表，栈，树，队列，集合，映射表等。

     容器分为  序列式容器:数组，队列，栈
               关联式容器: 链表，树

        算法分为质变算法和非质变算法
             质变算法: 运算过程中会更改区间内的元素的内容，例如替换，删除等
             非质变算法:是指运算过程中不会更改区间的元素内容，例如查找，遍历等

             迭代器:提供一种方法，使之能够依序访问某个容器所含的各个元素，每个容器都有自己的迭代器。
             迭代器非常类似于指针。

                 迭代器有五种

                     输入迭代器  对数据只读
                     输出迭代器  对数据只写
                     前向迭代器   读写操作并向前推进迭代器
                     双向迭代器    读写操作，并能向前和向后操作
                     随机访问迭代器   读写操作，可以跳跃访问任意数据

### 容器算法迭代器初识
  STL中最常用的容器是Vector,可以理解为数组。

```cpp
//for_each的回调
void func(int val){
 cout << val <<endl;
}
int main()
{
    vector<int> v;//创建这个容器
    v.push_back(10);//添加内容
    v.push_back(20);
    v.push_back(30);
    v.push_back(40);
    v.push_back(50);
    v.push_back(60);
    //通过迭代器访问
    // vector<int>::iterator pBegin=v.begin(); //这里的begin是一个指针，指向的是容器第一个元素的位置
    // vector<int>::iterator pEnd=v.end();//end也是一个指针，指针指向的是容器中最后一个元素的位置
    // //第一种遍历方式
    // while(pBegin != pEnd){
    //     cout << *pBegin <<endl;
    //     pBegin++;//移动到下一个元素的位置
    // }
    //第二种遍历方式
    // for( vector<int>::iterator pBegin=v.begin();pBegin!= v.end() ; pBegin++){
    //      cout << *pBegin<<endl;
    // }
    //通过标准算法库来进行访问
    vector<int>::iterator pBegin=v.begin(); 
    vector<int>::iterator pEnd=v.end();
    for_each(pBegin,pEnd,func);//接受三个参数，begin,end,回调函数(回调函数的参数就是容器中每一个元素的值)
    system("pause");
    return 0;
}
```
```cpp
 //vector容器，存放自定义数据类型
 #include <iostream>
using namespace std;
#include <string>
#include <vector>    //引入容器的头文件
#include <algorithm> //标准算法库的头文件
class Person
{
public:
    string name;
    int age;
    Person(string name, int age)
    {
        this->name = name;
        this->age = age;
    }
};
//添加自定义数据类型
void test01(){
    Person p1("aaa",20);
    Person p2("bbb",22);
    Person p3("ccc",23);
    Person p4("ddd",24);
    Person p5("eee",25);
    Person p6("fff",26);
    vector<Person> v;
    v.push_back(p1);
    v.push_back(p2);
    v.push_back(p3);
    v.push_back(p4);
    v.push_back(p5);
    v.push_back(p6);
    //进行遍历访问
    for(vector<Person>::iterator pBegin=v.begin();pBegin != v.end();pBegin++){
           cout << (*pBegin).name <<endl;
           cout << pBegin->age<<endl;//PBegin 是一个指针，直接通过->拿到数据
    }
}
//存放自定义数据类型指针
void test02(){
 Person p1("aaa",20);
    Person p2("bbb",22);
    Person p3("ccc",23);
    Person p4("ddd",24);
    Person p5("eee",25);
    Person p6("fff",26);
    vector<Person *> v;
    v.push_back(&p1);
    v.push_back(&p2);
    v.push_back(&p3);
    v.push_back(&p4);
    v.push_back(&p5);
    v.push_back(&p6);
    //进行遍历访问
    for(vector<Person *>::iterator pBegin=v.begin();pBegin != v.end();pBegin++){
      cout << (* pBegin)->name << " " << (* pBegin)->age <<endl;
     }
}

int main()
{
    test01(); 
    test02();
    system("pause");
    return 0;
}
```
### 容器嵌套容器
 容器嵌套容器就是，一个大容器里再嵌套多个小容器

```cpp
void test01()
{
    //创建一个大容器
    vector<vector<int>> bigV;
    //创建四个小容器
    vector<int> smallV1;
    vector<int> smallV2;
    vector<int> smallV3;
    vector<int> smallV4;
    //循环向小容器里添加数据
    for (int i = 0; i < 4; i++)
    {
        smallV1.push_back(i + 1);
        smallV2.push_back(i + 2);
        smallV3.push_back(i + 3);
        smallV4.push_back(i + 4);
    }
    //将小容器添加进小容器里
    bigV.push_back(smallV1);
    bigV.push_back(smallV2);
    bigV.push_back(smallV3);
    bigV.push_back(smallV4);
    //遍历大容器数据
    for(vector<vector<int>>::iterator it=bigV.begin(); it != bigV.end();it++){
       //遍历小容器的数据
       for(vector<int>::iterator sIt=(* it).begin();sIt!=(* it).end();sIt++){
        cout << (* sIt);
       }
       cout << endl;
    }
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
## string 容器
  string是c++风格的字符串，string本质上是一个类

  string  和 char *的区别
    char *是一个指针
    string  是一个类，类内部封装了char*,管理这个字符串


    string类内部封装了很多成员方法，增删改查。
### string的构造函数
  string(); 创建一个空的字符串
  string(const char * s) 使用字符串s 初始化
  string(const string& str) 使用一个string初始化另外一个string对象
  string(int n,char c) 使用n个字符c 初始化

```cpp
void test01()
{
  // string的构造函数
  //空构造
  string s1;
  cout << s1 <<endl;
  //使用char *构造
  const char * str="Hello World";
  string s2(str);
  cout << s2 <<endl;
  //使用一个string对象初始化另一个string
  string s3(s2);
  cout << s3 <<endl;
  //使用使用n个字符c初始化
  string s4(10,'a');
  cout << s4<<endl;
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### string容器-赋值操作
  string容器的赋值操作，既可以通过=操作(因为string类内部重写了=运算符),也可以通过成员函数assign操作

     赋值函数原型
       operator=(const char * s) || assign(const char * s)  char*类型字符串，赋值给当前的字符串

       operator=(const string s) 把字符串s赋值给当前字符串

       operator=(char c) 字符c赋值给当前字符串

       assign(const char * s,int n) 将s字符串的前n个字符赋值给当前的字符串

       assign(const string &s)    把s字符串赋值给当前字符串

       assign(int n,char c) 字符c赋值给当前字符串n次

```cpp
void test01()
{
  // string的赋值操作
  //空构造
  const char * str="Hello World";
  string s1;
  s1=str; //(operator=(const char *))
  cout << "s1 = "<<s1<<endl;
  string s2;
  s2.assign(str);// assign(const char *)
  cout << "s2 = "<<s2 << endl;
  string s3;
  string str1="Hello C++";
  s3=str1; // operator=(const string s)
  cout << "s3 = " << s3<<endl;
  string s4;
  s4='a';//operator=(char c)
  cout << "s4 = " << s4 <<endl;
  string s5;//assign(char * s ,int n)
  s5.assign(str,5);
  cout << "s5 = " << s5 <<endl;
  string s6;
  s6.assign(str1);
  cout << "s6 = "<< s6 <<endl;
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### 字符串拼接


      
        函数原型
          operator+=(const char *)；
          operator+=(const char c);
          operator+=(const string & str);
          append(char * s);
          append(const char * s,int n) 将s字符串的前n个字符拼接到当前字符串的末尾

          append(const string &s) 

          append(const string &s,int start,int end) 将字符s从start字符到end字符拼接到当前字符串

```cpp

void test01()
{
    //拼接字符串操作

    // operator+=(const char * str)
    string s1;
    const char *str = "Hello C++";
    s1 += str;
    cout << "s1 = " << s1 << endl;

    // operator+=(char c)

    string s2;
    char s = 'a';
    s2 += s;
    cout << "s2 = " << s2 << endl;

    // operator+=(const string & str)
    string s3;
    string str1 = "Hello World";
    s3 += str1;
    cout << "s3 = " << s3 << endl;

    // append(const char * s)
    string s4;
    const char * str2="Hello jingmao";
    s4.append(str2);
    cout << "s4 = " << s4 << endl;

    //append(const char * s ,int n)

    string s5;
    const char * str3="aaacccsa";
    s5.append(str3,6);
    cout << "s5 = " << s5 <<endl;

    // append(const string &s,int start,int end) 
    string str4="aaaaabbbbbsaeq2wqwe";
    string s6;
    s6.append(str4,6,9);
    cout << "s6 = " << s6 << endl;
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```

### string的查找和替换

 查找使用函数find 和rfind 
 替换使用函数replace

     
       
        函数原型

           find(const string & str,int pos =0)  查找str第一次出现的位置,pos是开始查找的位置

           find(const char * s,int pos,int n) 查找s的前n个字符第一次出现的位置

           find(cahr c,int pos=0); 查找字符c第一次出现的位置

           rfind(const string& str,int pos=最后一个字符的位置)  //查找str最后一次出现的位置从pos开始找，pos默认是最后一个字符的位置

           rfind(const char * s,int pos,int n) 查找s的前n个字符最后一次出现的位置

           rfind(char c,int pos=0;) 查找字符c最后一次出现的位置

           replace(int pos,int n,const string & str)  替换从pos开始n个字符为字符串str
           
           replace(int pos,int n,const char * s) 替换从pos开始的n个字符为字符串s

```cpp
void test01()
{ 
    //查找字符串
    string str1="abcdefgde";
    cout << str1.find("de") <<endl;//找到返回下标找不到返回-1
    cout << str1.rfind("de")<<endl;//find是从左往右找，rfind是从右往左找
}
void test02(){
    //替换字符串
    string str1="abcdefga";
    str1.replace(1,3,"1111");
    cout << str1 <<endl;
}
int main()
{
    test01();
    test02();
    system("pause");
    return 0;
}
```
### 字符串比较
  字符串之间的比较是按照字符的ASCLL码进行对比

    相等返回0
    大于返回1
    小于返回-1

通过函数compare进行比较

```cpp
void test01()
{ 
    //比较字符串
    string str1="hellos";
    string str2="hello";
    int result=str1.compare(str2);
    if(result == 0){
        cout << "str1 == str2" <<endl;
    }else if(result == 1){
        cout << "str 1 > str2 " <<endl;
    }else{
        cout << "str1 < str2" <<endl;
    }
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### 获取字符
 可以通过[index] 方式获取字符
 可以通过 at(index) 方式获取字符

```cpp
 void test01()
{ 
    //读写字符串
    string str1="hellos";
    for(int i=0;i<str1.size();i++){
        cout << str1[i] <<" " <<str1.at(i) <<endl;
    }
    //修改单个字符
    str1[3]='x';
    cout << str1 <<endl;
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### 插入和删除字符
 对字符串进行插入和删除操作

    函数原型
       
        insert(int start,string s) 从start位置开始插入字符串s

        insert(int start,int n,char c) 在指定位置start插入n个字符c

        erase(int start,int n) 删除从start开始的n个字符
```cpp
void test01()
{ 
    //插入和删除字符
    string str1="hellos";
    str1.insert(0,10,'1');
    str1.insert(11,"World");
    str1.erase(0,11);
    cout  << str1 <<endl;
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### 截取字符串
  通过substr函数进行获取子串

  substr(int start=0,int num); 从start的位置开始截取num个字符

```cpp
void test01()
{ 
    //插入和删除字符
    string str1="hellos";
    cout << str1.substr(0,3) <<endl;
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
## vector容器
  vector容器的结构和数组非常相似，也称为单端数组

   vector和普通数组的区别:
      普通数组是静态空间，vector可以动态扩展

动态扩展并不是在原空间继续新接空间，二十找更大的内存空间，将原有的数据拷贝到新空间，释放原空间
### vector构造函数
 
     vector<T> v  采用模板类实现，默认构造函数

     vector(v.begin(),v.end()); 将begin和end区间中的元素拷贝给当前容器

     vector(n,elem)  拷贝n个elem给当前容器

     vector(const vector &vec) 拷贝构造函数

```cpp
void printVector(vector<int> &v){
    for(vector<int>::iterator it=v.begin();it!=v.end();it++){
           cout<<*it<<" ";
    }
  cout << endl;
}
void test01()
{ 
 //vector构造函数
   //默认构造
    vector<int> v;
    for(int i=1;i<=10;i++){
        v.push_back(i);
    }
    printVector(v);
   //区间构造
    vector<int> v2(v.begin(),v.end());
    printVector(v2);
    //n个elem构造
    vector<int> v3(10,100);
    printVector(v3);
    //拷贝构造函数
    vector<int> v4(v3);
    printVector(v4);
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### vector的赋值操作

     operator= 重载等号操作符

     assign(begin,end) 将begin至end区间的数据赋值给本身

     assign(n,elem) 将n个elem赋值给本身

```cpp
void printVector(vector<int> &v){
    for(vector<int>::iterator it=v.begin();it!=v.end();it++){
           cout<<*it<<" ";
    }
  cout << endl;
}
void test01()
{ 
 //赋值操作
    vector<int> v;
    for(int i=1;i<=10;i++){
        v.push_back(i);
    }
    printVector(v);
//operator=
    vector<int> v2;
    v2=v;
  printVector(v2);
//assign
    vector<int> v3;
    v3.assign(v2.begin(),v2.end());
    printVector(v3);

    v3.assign(10,100);
    printVector(v3);

}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### vector的容量和大小


     
      函数原型
         
          empty 判断容器是否为空

          capacity  容器的容量

          size 返回容器中元素的个数

          resize 重新指定容器的长度为num,若容器变长则以默认值重新填充默认位置

          resize(int num,elem) 重新指定容器的长度为num,若容器变长则以elem填充新的位置，如果容器变短则末尾超出容器长度的元素被删除



```cpp
void printVector(vector<int> &v){
    for(vector<int>::iterator it=v.begin();it!=v.end();it++){
           cout<<*it<<" ";
    }
  cout << endl;
}
void test01()
{ 
 //赋值操作
    vector<int> v;
    for(int i=1;i<=10;i++){
        v.push_back(i);
    }
  if(!v.empty()){
   cout << "v No NULL" <<endl;
   cout << "v Size" << v.size() <<endl;
   cout << "v Capacity" << v.capacity() << endl;
   v.resize(20,100); //重新指定大小,如果超出原来的容量,第二个参数如果不写，默认用0去填充剩余位置
    printVector(v);
    v.resize(5);//重新指定大小，如果比原来的容量小，那么会删除多余的元素
    printVector(v);
  }else{
    cout << "v is NULL" <<endl;
  }
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### vector插入和删除
   
     
       函数原型

        push_back
        
        pop_back
        
        insert(iterator start,ele) 向start位置插入ele
        
        insert(iterator start,int count,ele) 向start位置插入count个ele

        erase(iterator start)  删除start位置的元素

        erase(iterator start,iterator end) 删除从start到end位置的元素

        clear 删除容器中所有元素

```cpp
void printVector(vector<int> &v){
    for(vector<int>::iterator it=v.begin();it!=v.end();it++){
           cout<<*it<<" ";
    }
  cout << endl;
}
void test01()
{ 
 //赋值操作
    vector<int> v;
    //尾插
    v.push_back(10);
    v.push_back(20);
    v.push_back(30);
    v.push_back(40);
    v.push_back(50);
    v.push_back(60);
    printVector(v);
    //尾删
    v.pop_back();
    printVector(v);
    //插入
    v.insert(v.begin(),66);
    printVector(v);
    v.insert(v.begin(),2,1000);
    printVector(v);
    //删除
    v.erase(v.begin());
    printVector(v);
    // //清空
    v.clear();
    printVector(v);
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```

### vector数据存取

  
     at(int index)   返回index位置的元素
     operator[index]  返回index位置的元素
     front()  返回容器中第一个元素
     back()  返回容器中最后一个元素 

```cpp
void test01()
{ 
    //数据存取
    vector<int> v;
    v.push_back(10);
    v.push_back(20);
    v.push_back(30);
    v.push_back(40);
    v.push_back(50);
    v.push_back(60);
    for(int i=0;i<v.size();i++){
        //通过operator=和at函数访问
        cout <<v[i] << " "<< v.at(i) <<endl;
    }
    //front
    cout<< "one First" << v.front() <<endl;
    //back
    cout << "back" << v.back() <<endl;
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### 互换容器
 实现两个容器内元素进行互换

 通过swap函数进行互换

 巧用容器互换能够收缩内存
 

 ```cpp
void printVector(vector<int> &v)
{
    for (vector<int>::iterator it = v.begin(); it != v.end(); it++)
    {
        cout << *it << " ";
    }
    cout << endl;
}
void test01()
{
    //互换
    vector<int> v;
    vector<int> v2;
    for (int i = 0; i < 10; i++)
    {
        v.push_back(i);
    }
    for (int i = 9; i >= 0; i--)
    {
        v2.push_back(i);
    }
    //互换前
    cout << "swap before" << endl;
    printVector(v);
    printVector(v2);
    cout << "swap hou" << endl;
    v.swap(v2);
    printVector(v);
    printVector(v2);
}
//实际用途
//巧用swap缩短内存空间
void test02()
{
    vector<int> v;
    //向容器中插入100000个是数据
    for (int i = 0; i < 100000; i++)
    {
        v.push_back(i);
    }
    cout << "v size" << v.size() << endl;
    cout << "v capaCity" << v.capacity() << endl;
    /**
     * 此时v的元素个数为10万，容量为131072
     * 接下来缩短v的大小
     */
    v.resize(3);
    cout << "v size" << v.size() << endl;
    cout << "v capaCity" << v.capacity() << endl;
    /**
     * 此时v的容量缩小后，v的元素个数为3，容量为131072
     * v的元素个数没有那么多，但是却占了较大的内存空间，比较浪费!!!
     * 所以我们需要巧用swap函数进行缩短内存空间
    */
   vector<int>(v).swap(v);
    cout << "v size" <<v.size()<<endl;
    cout << "v capaCity"<<v.capacity()<<endl;
    /**
     * 经过互换后v的容量为3，v的元素个数为3
     * 
     * vector<int>(v).swap(v) 代码的解释
     * 
     * vector<int>(v) 相当于调用了拷贝构造函数创建了一个匿名对象
     *  将这个匿名对象的内容，和v容器的内容进行互换，互换之后匿名对象就成为了占很多内存的那个容器
     *    但是匿名对象在执行完之后就会被系统回收，所以多占的内存空间也被内存回收掉了
    */
}
int main()
{
    //互换
    // test01();
    test02();
    system("pause");
    return 0;
}
 ```

 ### vector预留空间
  减少vector在动态扩展容量时的扩展次数

  reserve(int len) 容器预留len个元素长度，预留位置不初始化，元素不可访问

```cpp
void test01()
{ 
    //预留空间
    vector<int> v;

    int num=0;//统计动态扩展的次数
    int * p=NULL;
    v.reserve(10000);//提前预留空间,因为动态扩展每次都需要去找新的空间去存储数据，如果提前预留一定的空间存储则不会过多的去重新找空间
    //向容器里添加10000个数据，
    for(int i=0;i<10000;i++){
        v.push_back(i);
        if(p != &v[0]){
           p=&v[0];
           num++;
        }
    }
    cout << num <<endl;
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
## deque容器
 deque容器也被称为双端队列

 就是既然可以进行后进先出，也可以进行先进先出。

 deque与vector的区别
   
    vector对于头部的插入删除效率低，数据量越大，效率越低。
    deque相对而言，对头部的插入速度会比vector快
    vector访问元素时的速度会比deque快(这和两者的内部实现有关)。
    

    deque的工作原理:
      deque内部有个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据。
      中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间
### deque的构造函数
  
    
     deque<T> 默认构造
     
     deque(start,end) 将start至end的元素拷贝给自身
     
     deque(n,ele)  将n个elem拷贝给本身

     deque(const deque &deq) 拷贝构造函数

```cpp
void printDeque(const deque<int> &v)
{
     //加上const 使用迭代器，就是一个只读的迭代器，不能修改容器里的数据
    for (deque<int>::const_iterator it = v.begin(); it != v.end(); it++)
    {
        cout << *it << " ";
    }
    cout << endl;
}
void test01()
{
    //默认构造
    deque<int> d;
    for(int i=0;i<10;i++){
        d.push_back(i);
    }
    printDeque(d);
    //deque(start,end)
    deque<int> d2(d.begin(),d.end());
    printDeque(d2);
    //deque(10,100)
    deque<int> d3(10,100);
    printDeque(d3); 
    //拷贝构造函数
    deque<int> d4(d3);
    printDeque(d4);
}
int main()
{
    test01();
    system("pause");
    return 0;
} 
```
### deque赋值操作 
 
    
     函数原型

       operator=(const deque &deq) 重载等号

       assign(start,end) 将start至end区间的数据赋值给本身

       assign(n,elem) 将n个elem赋值给本身

```cpp
void printDeque(const deque<int> &v)
{
     //加上const 使用迭代器，就是一个只读的迭代器，不能修改容器里的数据
    for (deque<int>::const_iterator it = v.begin(); it != v.end(); it++)
    {
        cout << *it << " ";
    }
    cout << endl;
}
void test01()
{
    //赋值操作
    deque<int> d;
    for(int i=0;i<10;i++){
        d.push_back(i);
    }
    printDeque(d);
    //operator=
    deque<int> d2;
    d2=d;
    printDeque(d2);
    //assign(start,end)
    deque<int> d3;
    d3.assign(d2.begin(),d2.end());
    printDeque(d3);
    //assign(num,ele)
    deque<int> d4;
    d4.assign(10,100);
    printDeque(d4);
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### deque大小操作

     函数原型

        empty 判断容器是否为空

        size 元素个数

        resize(num,elem) 重新指定长度，
```cpp
void test01()
{
    //赋值操作
    deque<int> d;
    for(int i=0;i<10;i++){
        d.push_back(i);
    }
    if(!d.empty()){
       cout << "d No NULL" <<endl;
       cout << "d size" << d.size() <<endl;;
    }else{
        cout << "d is NULL" <<endl;
    }
    //改变大小
    d.resize(20,1);//将长度扩展为20 ,多余用1代替
    printDeque(d);
   d.resize(5); //将长度缩短为5,多余的元素删除
    printDeque(d);
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### deque的插入和删除
   
    
     函数原型 
        push_back 
        
        pop_back
        
        push_front 头插
        
        pop_front 头删

        insert(start,elem) 在start位置插入elem,返回新数据的位置

        insert(start,n,elem) 在start位置插入n个elem，无返回值

        insert(pos,start,end)  在pos位置插入从start至end位置的数据无返回值

        clear() 清空容器

        erase(start,end) 删除start至end区间的数据，返回下一个数据的位置

        erase(start) 删除start位置的数据，返回下一个数据的位置

```cpp
void test01()
{
    //插入和删除
    deque<int> d;
    //插入
     d.push_back(10);
     d.push_back(20);
     d.push_front(100);
     d.push_front(200);
     printDeque(d);
    //删除
      d.pop_back();
      d.pop_front();
      printDeque(d);
    //insert
     d.insert(d.begin(),200);
     d.insert(d.end(),200);
     d.insert(d.begin(),3,1000);
     d.insert(d.begin(),d.begin(),d.end());
     printDeque(d);
     //erase
     d.erase(d.begin());
     printDeque(d);
     //clear
     d.clear();
     printDeque(d);

}
int main()
{
    test01();
    system("pause");
    return 0;
}
```

### deque的数据存取
  
     函数原型
       at(index)
       operator[index]
       front
       back
```cpp
void test01()
{
    //数据存取
    deque<int> d;
    //插入
     d.push_back(10);
     d.push_back(20);
     d.push_front(100);
     d.push_front(200);
    //读数据
    cout << d.front() <<endl;
    cout << d.back() <<endl;
    cout << d[0] <<endl;
    cout << d.at(0) <<endl;
    //修改数据
    d[0]=1000;
    cout << d[0] <<endl;
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### deque排序
 利用算法实现对deque容器进行排序

 算法: 
   sort(start,end)

```cpp
void test01()
{
    //数据存取
    deque<int> d;
    //插入
     d.push_back(10);
     d.push_back(1000);
     d.push_back(20);
     d.push_front(200);
     d.push_front(600);
     cout << "sort beigin" <<endl;
     printDeque(d);
     cout << "sort end" <<endl;
     sort(d.begin(),d.end());
     printDeque(d);
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
```cpp
/**
   vector容器和deque容器实战

   评委打分
     创建五名选手，放到Vector中
     遍历vector容器，取出来一个选手进行for循环，把10个评分放入到deque容器中
     sort算法对deque进行排序，去除最低分和最高分
     过滤一遍deque，累加总分
 */
 #include <iostream>
using namespace std;
#include <string>
#include <deque>
#include <algorithm>
#include <vector>
#include <ctime> //系统时间
class Person
{
public:
    string name;
    int source;
    Person(string name)
    {
        this->name = name;
    }
    void showInfo()
    {
        cout << this->name << " " << this->source << endl;
    }
};
void createPerson(vector<Person> &v)
{
    string names = "ABCDE";
    for (int i = 0; i < names.size(); i++)
    {
        string name = "xs";
        name += names[i];
        Person p(name);
        v.push_back(p);
    }
};
void sourcePerson(vector<Person> &v)
{
    //遍历五位选手
    for (vector<Person>::iterator it = v.begin(); it != v.end(); it++)
    {
        //创建deque容器用于存储分数
        deque<int> d;
        //循环10次，用随机数模拟法分数
        for (int i = 0; i < 10; i++)
        {
            //随机数代替100,取0-40的随机数最后再加60
            int source = rand() % 41 + 60;
            //将随机数放入deque
            d.push_back(source);
        }
        //去掉一个最高分，去掉一个最低分
        //先用sort进行排序
        sort(d.begin(), d.end());
        d.pop_back();
        d.pop_front();
        //显示一下随机数
        // cout << (*it).name << endl;
        // for (deque<int>::iterator dit = d.begin(); dit != d.end(); dit++)
        // {
        //     cout << *dit << " ";
        // }
        // cout << endl;

        //计算平均分
        int zongSource=0;
        for(deque<int>::iterator dit = d.begin(); dit != d.end();dit++){
            zongSource+=(*dit);
        }
        int source=zongSource/d.size();

        //将平均分赋值给选手
        (*it).source=source;
       
    }
}
void printVector(vector<Person> &v)
{
    for (vector<Person>::iterator it = v.begin(); it != v.end(); it++)
    {
        (*it).showInfo();
    }
}
int main()
{
    srand((unsigned int)time(NULL)); //随机数种子,用随机数种子让程序根据系统时间获取所记述
                                     // 创建五名选手放到vector容器中
    vector<Person> v;
    //创建五位选手
    createPerson(v);
    // 评委打分，并计算随机数
    sourcePerson(v);
    printVector(v);
    system("pause");
    return 0;
}
```
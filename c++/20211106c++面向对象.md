# 内存分区模型
 
        
         代码区:存放函数体的二进制代码，由操作系统进行管理。
         全局区：存放全局变量和静态变量以及全局常量
         栈区:由编译器自动分配释放,存放函数的参数值，局部变量等
         堆区:由程序员分配和释放，若程序员不释放程序结束时由操作系统回收。

         内存四区存在的意义:
          不同区域存放不同的数据，赋予不同的生命周期
        
## 程序运行前
 在程序编译后，生成了exe可执行程序，未执行该区域前分为两个区域。
   
     代码区： 
       存放cpu执行的机器指令
       代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可，代码区是制度的，使其只读是为了防止程序意外的修改他的指令
    全局区： 
       全局变量和静态变量存放在此
       全局区还包含了常量区，字符串常量和其他常量也存放在此。
       该区域的数据在程序结束后由操作系统释放。

  ## 程序运行后

        
         栈区：
            由编译器进行分配和释放。
            不要返回局部变量的地址，栈区分配的数据由编译器自动释放。
```cpp
#include <iostream>
using namespace std;
int* func(){
    int  a=10;
    return &a;
}
int main(){
    int * p=func();
    cout << *p << endl;//第一次输出正确的值，因为编译器做了保留
    cout << *p << endl;//第二次输出乱码，因为局部变量保存在栈中，栈中的数据编译器进行释放
    system("pause");
    return 0;
}
```
## 程序运行后
  
       堆区 
          由于程序员分配释放，若程序员不释放，则程序结束后由操作系统回收和释放。
          用new关键字在堆区进行开辟内存

```cpp
int* func(){
     /*
      new 关键字用来在堆中开辟内存，new关键字返回的是一个地址
      用指针来保存,指针是局部变量
     */
    int * a=new int(10);
    return a;
}
int main(){
    int * p=func();
    cout << *p << endl;//一直输出10
    cout << *p << endl;//一直输出10,只要不被释放，只有当程序结束时由操作系统释放
    system("pause");
    return 0;
}
```
## new操作符
  c++中用new操作符在堆区开辟内存。
  堆区开辟的内存手动开辟，手动释放，释放delete操作符。
  利用new创建的数据，会返回该数据对应的类型的指针。
```cpp
#include <iostream>
using namespace std;
int * func(){
    int * a=new int(10);
    return a;
 }
void test01(){
    int * p=func();
    cout << *p<<endl;
    cout << *p<<endl;//未释放就一直存在
    delete p;//释放内存
    cout << *p<<endl;//出现乱码
}
void test02(){
    int * arr=new int[10];//在堆内存中放数组
    for(int i=0;i<10;i++){
        arr[i]=i+100;
    }
    for(int i=0;i<10;i++){
        cout << arr[i] << endl;
    }
    delete [] arr;//释放数组内存
    for(int i=0;i<10;i++){
        cout << arr[i] << endl;
    }
}
int main(){
    test02();
    system("pause");
    return 0;
}
```
# 引用
  引用就是给变量起别名

    数据类型 &别名=原名;
```cpp
int main(){
    int a=10;
    int &b=a; //创建引用
    cout << "a =" << a<<endl;
    cout << "b =" << b <<endl;
    b=100;
    cout << "a =" << a<<endl;
    cout << "b =" << b <<endl;
    system("pause");
    return 0;
}
```
## 注意事项
 引用必须要初始化赋值。
 引用一旦初始化后就不可以再更改。
```cpp
int main(){
    int a=10;
    //int &b; 引用必须初始化
    int &b=a; 
    int c=20;
    b=c;// 这是赋值操作不是修改引用
    cout << "a =" << a <<endl;
    cout << "b =" << b <<endl;
    cout << "c =" << c <<endl;
    system("pause");
    return 0;
}
```
## 引用做函数参数

   作用：函数传参时，可以利用引用的技术让形参修改实参，
   优点：简化指针。
```cpp
void swap(int &a,int &b){
    // 利用引用接收传递过来的实参，进行修改实参
   int temp=a;
    a=b;
    b=temp;
}
int main(){
    int a=10;
    int b=20;
    swap(a,b);
    cout << "a =" << a <<endl;
    cout << "b  =" << b << endl;
    system("pause");
    return 0;
}
```
## 引用做函数返回值
  引用也可以做函数的返回值，但是注意不要返回局部变量的引用。

```
int & swap(){
 static int a=10;//因为不能返回局部变量的引用，所以把变量提升为静态变量(静态变量保存在全局区)
  return a;
}
int main(){
    int &refa=swap();//因为返回了引用所以要用引用去接收
    cout << "refa =" << refa <<endl;
     cout << "refa =" << refa <<endl;
     //函数最为左值,函数做为左值必须返回引用
     swap()=1000;//因为返回的引用，所以这个赋值为1000相当于改的引用的值
     cout << "refa =" << refa <<endl;
     cout << "refa =" << refa <<endl;
    system("pause");
    return 0;
}
```
## 引用的本质
 引用的本质在c++中内部实现是一个指针常量，

## 常量引用
 常量引用主要用来形式形参，防止误操作

```cpp
#include <iostream>
using namespace std;
void swap(const int &a){
    cout <<a << endl;
    a=1000;
    //使用了常量引用之后就不可以再去进行修改
    cout << a<< endl;
}
int main(){
    int a=100;
    swap(a);
    system("pause");
    return 0;
}
```
# 函数提高

## 函数的参数默认值
 就是形参的默认值。
 如果函数分开写，那么声明函数和实现函数只能有一个的参数写默认值。
```cpp
#include <iostream>
using namespace std;
void add(int a,int b=20 ,int c=50){
    // 一旦一个参数有了默认值，那么它之后的所有参数都必须要有默认值
  cout << (a+b+c) << endl;
 }
int main(){
    add(10);//有默认值的参数，如果传了该参数就用传的参数，没有就用默认值
    system("pause");
    return 0;
}
```
## 函数的占位参数
 c++的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置
  
   返回值类型 函数名(数据类型) {}
```cpp
void add(int a,int){
  cout << "this is Add" << endl;
 }
int main(){
    add(10,20);//占位参数一定要传递，否则无法调用该函数
    system("pause");
    return 0;
}
```
## 函数重载
 作用名：函数名可以相同，提高复用性

         满足条件
           同一个作用域下
           函数名称相同
           函数参数类型不同或者个数不同或者顺序不同
```cpp
void func(){
    cout << "This is func ()" <<endl;
}
void func(int a){
  cout << "This is func (int a)"<<endl;
}
void func(double a){
    cout << "This is func(double a)" <<endl;
}
void func(int a,double b){
    cout << "This is func(int a,double b)"<<endl;
}
void func(double b,int a){
    cout << "This is func(double b,int a)"<<endl;
}
int main(){ 
  /*
    参数个数不同  
    func();
    func(10);
   */ 
  /*
  参数类型不同
  func(10)
  func(3.14)；
  */
 /* 参数顺序不同
 func(10,3.14);
 func(3.14,10);
 */
    system("pause");
    return 0;
}
```
# 类和对象
 面向对象的三大特性:封装，继承，多态
  c++认为万物皆是对象，对象上有其属性和行为。

## 封装
 将属性和行为作为一个整体。
 将属性和行为加以权限控制。
  class{权限 属性/方法}

```cpp
#include <iostream>
using namespace std;
const double PI=3.14;
class Cricle{
    public :
        int r;
        double compute(){
           return 2*PI*r;
        }
};
int main(){ 
    //对类进行实例化,在c++中对类进行实例化不能使用new 关键字，因为new关键字是在堆中开辟内存的
    /*
    * 一个简单的猜想，因为c++算底层语言，js和java算是高级语言
      因为js和java里去实例化类需要用到new关键字，然后在c++里用new关键字是在堆内存里去开辟空间的,js里的类的实例化是存在堆内存里的，node是用c++写的，所以js里去实例化一个类用new关键字，相当于告诉c++在堆内存里开辟一块空间，用来存储当前的对象。
     */
    Cricle c1;
    c1.r=10;
    cout << c1.compute() << endl;
    system("pause");
    return 0;
}
```
### 访问权限

        
         public 公共权限  类内可以访问，类外可以访问
         private 私有权限  类内可以访问，类外不可以访问，子类不能访问
         protected 保护权限  类内可以访问，类外不可以访问，子类可以访问

### struct 和class的区别
 struct和class的区别就在于默认的访问权限不同。
  
   struct的默认权限是共有的
   class 的默认权限是私有的
### 成员属性私有化
  成员属性私有后，可以自己控制读写权限，对于写权限可以检验数据的有效性
```cpp

class Person{
    private :
      string name;
      int age;
    public :
      void setName(string names){
           name=names;
      };
      string getName(){
         return name;
      };
      void setAge(int num){
        //控制数据的有效性
             if(num < 0 || num >150){
                cout << "you are dog ???" << endl;
                return;
             }else{
                age=num;
             }
      }
      int getAge(){
        return age;
      }
};
int main(){
    Person p1;
    p1.setName("Tom");
    cout << p1.getName() << endl;
    p1.setAge(10);
    cout << p1.getAge() <<endl;
    system("pause");
    return 0;

}
```
```cpp
//封装实战demo,
// 设计立方体类，求出立方体的面积和体积
// 分别利用全局函数和成员函数判断两个立方体是否相等
#include <iostream>
using namespace std;
#include <string>
const double PI = 3.14;
class Cube
{
private:
    int l; //长
    int w; //宽
    int h; //高
public:
    //设置和获取长宽高
    void setL(int L) { l = L; }
    void setW(int W) { w = W; }
    void setH(int H) { h = H; }
    int getL() { return l; }
    int getW() { return w; }
    int getH() { return h; }
    //获取面积
    int mj() { return ((2 * l * w) + (2 * w * h) + (2 * l * h)); }
    //获取体积
    int tj() { return l * h * w; }
    //利用成员函数判断两个立方体是否相等
    bool equal(Cube &c)
    {
        if ( l == c.getL() && h == c.getH() && w == c.getW())
        {
            return true;
        }
        else
        {
            return false;
        }
    }
};
//利用全局函数判断是否相等
bool isSem(Cube &c1, Cube &c2)
{
    if (c1.getL() == c2.getL() && c1.getH() == c2.getH() && c1.getW() == c2.getW())
    {
        return true;
    }
    else
    {
        return false;
    }
}
int main()
{
    Cube c1;
    c1.setH(10);
    c1.setL(10);
    c1.setW(10);
    Cube c2;
    c2.setH(10);
    c2.setL(10);
    c2.setW(10);
    //成员函数判断
    bool ret = c1.equal(c2);
    if (ret)
    {
        cout << "c1 == c2" << endl;
    }
    else
    {
        cout << "c1 != c2 " << endl;
    }
    //全局函数判断
    // bool ret = isSem(c1, c2);
    // if (ret)
    // {
    //     cout << "c1 == c2" << endl;
    // }
    // else
    // {
    //     cout << "c1 != c2 " << endl;
    // }
    system("pause");
    return 0;
}
```
##  对象的初始化和清理
### 构造函数和析构函数
 构造函数和析构函数是编译器自动去调用的，如果开发不提供构造函数和析构函数那么编译器会自动实现的空实现。
   构造函数：主要作用于在创建对象时为对象的成员属性赋值，构造函数由编译器自动调用。
   析构函数：主要作用于在对象销毁前系统自动调用，执行一些清理工作

       构造函数语法 
           类名(){}
            构造函数，没有返回值也不写void
            函数名称与类名相同
            构造函数也可以有参数，因此可以发生重载
            程序在实例对象时，会自动调用


        析构函数语法： ~类名(){}
          析构函数，没有返回值也不写void
          函数名称与类名相同，在名称前加上符号~
          析构函数不可以有参数，因此不可以发生重载
          程序在对象销毁前自动调用析构，无须手动调用而且只会调用一次。
```cpp
class Person{
    public :
      Person(){
           cout << "this is gz" << endl;
        }
      ~Person(){
         cout << "this is jg" << endl;
      }  
};
void test01(){
    Person p;
}
int main()
{
    Person p1; // 因为main函数一直没有结束所以这里不会触发到析构函数
    test01(); //在test方法里，会触发到析构函数，因为test函数执行完了，对象要被回收掉
    system("pause");
    return 0;
}
```
### 构造函数的分类及调用
  按参数分为：有参构造和无参构造
  按类型分为：普通构造和拷贝构造

  调用方法：括号法，显示法，隐式转换法


     注意事项：
        不要利用拷贝构造函数，初始化匿名对象
        不要用()调用无参构造函数
```cpp
class Person{
    public :
    int age;
      Person(){
        //无参构造
           cout << "this is gz" << endl;
        }
     Person(int a){
        age=a;
        cout << "yc" << endl;
        //有参构造
     }
     Person(const Person &p){
        age=p.age;
        cout << "copy"<<endl;
       //拷贝构造
     }
};
void test01(){
    //默认构造函数
    Person p1;
    //括号法
    //  Person p2(10);//调用有参构造函数
    //  Person p3(p2);//拷贝构造函数 
    //显示法
    // Person p2=Person(10); //调用有参构造函数
    // Person p3=Person(p2); // 调用拷贝构造函数
    // 隐式调用法
    Person p4=10; //调用有参的构造函数
    Person p5=p4; //调用拷贝构造函数
}
int main()
{
    test01();
    system("pause");
    return 0;
}
```
### 拷贝构造函数的调用时机
   
        拷贝构造函数调用实际的三种情况: 
            使用一个已经创建完毕的对象来初始化一个新对象。
            值传递的方式给函数参数传值
            以值方式返回局部对象
```cpp
class Person{
    public :
    int age;
      Person(){
        //无参构造
           cout << "this is gz" << endl;
        }
     Person(int a){
        age=a;
        cout << "yc" << endl;
        //有参构造
     }
     Person(const Person &p){
        age=p.age;
        cout << "copy"<<endl;
       //拷贝构造
     }
     ~Person(){
        cout << "xg" <<endl;
     }
};
// void test01(){
//     //使用一个已经创建完毕的对象初始化一个新对象
//     Person p1(10);
//     Person p2(p1);
// }
// void doWork(Person p){

// }
// void test02(){
//     //值传递的方法给函数参数传值
//  Person p;
//  doWork(p);
// }

Person doWork02(){
//以值方式返回局部对象
 Person p1(10);
 return p1;
}
void test03(){
  Person p=doWork02();
  cout << &p << endl;
}
int main()
{
    test03();
    system("pause");
    return 0;
}
```
### 构造函数的调用规则
  默认情况下 c++至少给一个类添加三个函数

     默认构造函数(无参，函数体为空)
     默认析构函数(无参，函数体为空)
     默认拷贝构造函数，对属性值进行拷贝


        构造函数的调用规则
          
            如果用户定义有参构造函数，c++不在默认提供无参构造，但是会提供默认拷贝构造。
            如果用户自定义拷贝构造函数，c++不会再提供其他构造函数。
### 深拷贝和浅拷贝
   浅拷贝 ： 简单的赋值拷贝操作
   深拷贝 :  在堆区重新申请空间，进行拷贝操作

   利用编译器提供的拷贝构造函数会做浅拷贝操作；
   浅拷贝带来的问题就是，堆区的内存被重复释放(解决这个问题的办法就是重写拷贝构造函数)。

```cpp
#include <iostream>
using namespace std;
#include <string>
const double PI = 3.14;
class Person{
    public :
    int age;
    int *height;
     Person(int a,int h){
        height=new int(h);
        age=a;
        cout << "yc" << endl;
        //有参构造
     }
     Person(const Person &p){
        //重写拷贝构造函数，避免浅拷贝带来的问题
         age=p.age;
         height=new int(*p.height);
     }
     ~Person(){
        // 将最堆区开辟的数据进行释放掉
        if(height != NULL){
            delete height;
            height=NULL;
        }
        cout << "xg" <<endl;
     }
};
void test01(){
    Person p1(10,160);
    cout << "p1 this age" << p1.age << *p1.height <<endl;
    Person p2(p1);
    cout << "p2 this age" << p2.age << *p2.height <<endl;
}

int main()
{
    test01();
    system("pause");
    return 0;
}
```
### 初始化列表
 c++提供了初始化列表语法，用来初始化属性
  构造函数():属性1(值1),属性2(值2)...{}

```cpp
class Person{
    public :
    int a;
    int b;
    int c;
    Person():a(10),b(20),c(30){}
};
int main()
{
     Person p;
     cout << p.a << p.b << p.c << endl;
    system("pause");
    return 0;
}
//这种方法，很好的代替了传统的属性赋初始化值的操作
```
### 类对象作为类成员
 c++中的成员可以是另一个类的对象，我们称该成员为对象成员。
 当一个类中的成员是一个类时，会先执行成员类的构造再执行自身的构造
```cpp
class Phone{
    public :
     string p_name;
     Phone(string name):p_name(name){
        cout << "phone gz"<<endl;
     }
};
class Person{
    public :
    string name;
    Phone iphone;
    Person(string name,string phone):name(name),iphone(phone){
         cout<<"p gz"<<endl;
    }
};
int main()
{
     Person p("Tom","iphone 14");
     cout << p.name << "hava a" << p.iphone.p_name <<endl; 
    system("pause");
    return 0;
}
```
### 静态成员
 静态成员就是在成员变量和成员函数前加上关键字static,称为静态成员。

     静态成员变量：
        所有对象共享同一份数据
        在编译阶段分配内存
        类内声明，类外初始化
     静态成员函数：
        所有对象共享同一个函数
        静态成员函数只能访问静态成员变量
```cpp
class Person{
    public :
     static string name;
     static void func(){
        cout << "func "<<endl;
     }
};
int main()
{ 
     //通过对象访问静态函数
     Person p;
     p.func();
     // 通过类名访问静态函数
     Person ::func();
    system("pause");
    return 0;
}
```
## 对象模型和this指针
### 成员变量和成员函数分开存储
 在c++中，类内的成员变量和成员函数分开存储，只有非静态成员变量才属于类的对象上